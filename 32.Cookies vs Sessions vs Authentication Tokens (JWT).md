# Cookies vs Sessions vs Authentication Tokens (JWT)

This document provides a **security-focused and architectural comparison** of **Cookies**, **Server-Side Sessions**, and **Authentication Tokens (JSON Web Tokens — JWT)**.  
It explains how each mechanism works, how they differ, their security implications, and when to use them.

---

## 1. Cookies

### What They Are
- Small key-value data items stored in the user's browser
- Automatically sent by the browser with every HTTP request to the same domain (depending on scope)

> Cookies are a **transport and storage mechanism**, not an authentication method by themselves.

### What They Store
- Session identifiers
- JWTs or other tokens
- User preferences (language, theme)
- Feature flags or tracking data

⚠️ Cookies should **not store sensitive data in plaintext**.

### Key Properties
Cookies can be restricted using attributes:

- **HttpOnly**  
  Prevents access via JavaScript, mitigating XSS-based theft.

- **Secure**  
  Ensures cookies are only sent over HTTPS.

- **SameSite**  
  Controls cross-site cookie sending behavior and helps mitigate CSRF.
  - `Strict`
  - `Lax`
  - `None` (requires `Secure`)

### Example
    Set-Cookie: session_id=abc123; HttpOnly; Secure; SameSite=Lax
### Advantages
Automatically sent by the browser

- First-class browser support
- Strong CSRF defenses when properly configured
- Well-suited for traditional web applications

### Limitations
- Vulnerable to CSRF if SameSite is misconfigured
- Size limit of ~4 KB per cookie
- Less suitable for mobile or third-party API usage
- Cookie scope can be tricky (domain, subdomain, path)

## 2. Sessions (Server-Side Authentication)
### What They Are
- Authentication state stored entirely on the server
- Client stores only a session identifier (usually in a cookie)

The server maintains a mapping between the session ID and user data.

## Authentication Flow
1. User submits credentials
2. Server validates credentials
3. Server creates a session object
4. Session ID is returned to the client in a cookie
5. Server retrieves session data on every request

### Example

    Client:
    Cookie: session_id=abc123
    
    Server:
    abc123 → { user_id: 42, role: "user" }

### Advantages
- Easy to revoke and invalidate sessions
- Sensitive data never leaves the server
- Mature and well-understood security model
- Strong control over user state

### Limitations
- Requires server-side storage (memory, database, Redis)
- Harder to scale horizontally
- Not ideal for APIs or microservices

## 3. Authentication Tokens (JSON Web Tokens — JWT)
### What They Are
- Self-contained authentication tokens
- Cryptographically signed (and optionally encrypted)
- Carry claims about the user and authorization context

JWTs enable stateless authentication.

### Token Structure

    HEADER.PAYLOAD.SIGNATURE

- Header: Algorithm and token type
- Payload: Claims (user ID, roles, expiration)
- Signature: Integrity verification

### Example Payload
    
    {
      "sub": "42",
      "role": "admin",
      "iat": 1709990000,
      "exp": 1710000000
    }

### Authentication Flow
1. User authenticates
2. Server issues a signed JWT
3. Client stores the token (cookie or storage)
4. Client sends the token with each request

### Common Usage

    Authorization: Bearer <JWT>

### Advantages
- Stateless and highly scalable
- No server-side session storage required
- Ideal for APIs, mobile apps, and microservices
- Enables decentralized authorization

### Limitations
- Difficult to revoke immediately
- Token theft grants access until expiration
- Payload is Base64URL-encoded, not encrypted
- Poor design can lead to severe security issues

### Comparison Table
| Feature              | Cookies | Sessions | JWT |
|----------------------|---------|----------|-----|
| Stored on client     | Yes     | No       | Yes |
| Stored on server     | No      | Yes      | No  |
| Stateless            | No      | No       | Yes |
| Horizontal scaling   | Limited | Difficult| Excellent |
| Easy revocation      | Limited | Yes      | No  |
| CSRF exposure        | Yes     | Yes      | No* |
| XSS exposure         | Medium  | Medium   | High |
| API-friendly         | No      | No       | Yes |


* JWTs sent via headers are not subject to CSRF. JWTs stored in cookies are.

## vSecurity Considerations (Pentesting Perspective)
### Cookies & Sessions
Test for:
- Missing HttpOnly, Secure, or SameSite
- Session fixation vulnerabilities
- Session reuse after logout
- Predictable session identifiers
- Insecure cookie scope

Ensure:

- CSRF tokens are implemented
- Sessions are rotated on privilege change

## JWT
Test for:

- alg: none or weak signing algorithms
- Missing or long-lived exp claims
- Token reuse after logout
- Trusting client-supplied jwk headers
- Improper signature validation

⚠️ Never trust JWT payload claims without cryptographic verification.

## When to Use Each Approach
### Use Sessions with Cookies When
- Building traditional web applications
- Immediate revocation is required
- Security is prioritized over scalability
- Centralized authentication is acceptable

### Use JWT When
- Building REST or GraphQL APIs
- Supporting mobile or desktop clients
- Designing microservice architectures
- Implementing OAuth2 or SSO systems

### Recommended Hybrid Approach
- Store JWTs in HttpOnly, Secure cookies
- Use short-lived access tokens
- Use refresh tokens with rotation
- Enforce CSRF protection
- Maintain a token revocation strategy if required

## One-Line Summary
Cookies are a storage and transport mechanism, sessions are server-side authentication state, and JWTs are stateless, portable authentication proofs.
