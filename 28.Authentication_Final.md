# Password Reset

## Password Reset

Password reset functionality allows users to regain access to their accounts when they forget their password or when a credential change is required for security reasons. This functionality is typically available on the login page or through a dedicated password reset workflow.

## Typical Password Reset Flow

A secure password reset process generally includes the following steps:

1. The user initiates a password reset request by submitting their registered email address or username.
2. The system generates a time-bound, cryptographically secure reset token or OTP.
3. The reset token or link is sent to the user's registered email address or mobile number.
4. The user accesses the password reset page by clicking the link or entering the OTP.
5. The user sets and confirms a new password.
6. The system validates the token and updates the password, allowing the user to log in with the new credentials.

## Common Password Reset Vulnerabilities

Password reset mechanisms are a frequent target for attackers and may contain the following weaknesses:

### 1. Weak or Guessable Security Questions
- Security questions with predictable answers can allow attackers to bypass identity verification.

### 2. Improper Email or Mobile Verification
- Failure to verify ownership of submitted email address or phone number may enable unauthorized password resets.

### 3. Weak or Predictable Reset Tokens
- Reset tokens that are short, guessable, reusable, or poorly randomized can be brute-forced or predicted.

### 4. Missing or Weak Rate Limiting
- Lack of rate limiting on password reset requests or OTP submissions can enable brute-force attacks or email bombing.

### 5. Lack of Logging and Monitoring

---

# Username/User Email Enumeration

## Username / User Email Enumeration

Username/user email enumeration is a technique used by attackers to identify valid user accounts within an application by submitting different username or email inputs and analyzing variations in the application's responses. Differences in error messages, response behavior, or timing can allow an attacker to distinguish between valid and invalid accounts.

## Enumeration Test Cases

The following test cases should be performed to identify potential username or email enumeration vulnerabilities:

### 1. Error Messages
- Verify whether the application returns different error messages for valid versus invalid usernames or email addresses.

### 2. Response Timing
- Measure response times for valid and invalid usernames to identify any noticeable timing discrepancies that could indicate account existence.

### 3. HTTP Response Codes
- Check whether different HTTP status codes (e.g., 200, 401, 403, 404) are returned for valid and invalid usernames.

### 4. Client-Side Source Code
- Review the login and authentication page source code (HTML, JavaScript) for hardcoded checks, comments, or API responses that may reveal valid usernames.

### 5. Password Reset Functionality
- Test the password reset workflow to ensure it does not disclose whether a username or email address exists (e.g., through confirmation messages or emails).

## Username Enumeration-Prone Endpoints

The following endpoints commonly expose username or email enumeration risks and should be tested thoroughly:

### 1. `/login` or `/signin`
- Authentication endpoints where credential validation may reveal account existence.

### 2. `/forgotpassword` or `/password-reset`
- Password recovery endpoints that may disclose whether a user account exists.

### 3. `/register` or `/signup`
- Registration endpoints that may reveal whether a username or email is already in use.

### 4. `/api/login`
- API authentication endpoints that may return distinct responses for valid and invalid users.

### 5. `/account`
- Authenticated user account endpoints that may behave differently based on username validity.

### 6. `/admin`
- Administration login endpoints that may disclose valid administrator usernames.

### 7. `/username-lookup`
- Endpoints explicitly designed to check username availability.

### 8. `/user/[username]`
- Public user profile endpoints that reveal valid usernames through accessible profiles.

### 9. `/search`
- User search functionality that may allow enumeration through partial or full username queries.

### 10. `/profile/[username]`
- Profile pages that indicate whether a username exists.

### 11. `/members`
- Endpoints displaying lists of users or members.

### 12. `/user-list`
- APIs or pages returning user listings.

### 13. `/user/[username]/settings`
- Account settings endpoints that may reveal username validity through access control responses.

### 14. `/validate/username`
- Username validation endpoints that explicitly confirm whether a username exists or is available.

## Common Password Reset Flaws

The following flaws are commonly observed during security assessments:

1. Password reset token leakage via HTTP Referer header
2. Account takeover through password reset poisoning
3. Password reset by manipulating the email or username parameter
4. Full account takeover by modifying email and password via API parameters
5. No rate limiting leading to email bombing attacks
6. Missing rate limiting on reset token or OTP validation
7. Predictable or weak password reset token generation
8. Acceptance of expired or previously used reset tokens
9. Brute-forcing password reset tokens or OTPs
10. Reusing another user's valid reset token
11. Password reset links that never expire
12. Denial of service via extremely long password input
13. User enumeration through password reset responses
14. Weak cryptographic implementation for tokens or OTPs
15. Token leakage via password reset poisoning
16. Token leakage through Host Header poisoning
17. Sending an array of email addresses instead of a single recipient
18. OTP brute-forcing during password reset
19. Response manipulation (forcing success responses from failure cases)

## References

- **Infosec Writeups – Password Reset Vulnerabilities**
  `https://infosecwriteups.com/all-about-password-reset-vulnerabilities-3bba86ffedc7`
- **Anugrah SR – 10 Password Reset Flaws**
  `https://anugrahsr.github.io/posts/10-Password-reset-flaws/`

---

## Password Reset-Related Endpoints

The following endpoints should be tested for password reset vulnerabilities:

### 1. `/reset-password` or `/forgot-password`
- Initiates the password reset request.

### 2. `/change-password`
- Allows authenticated users to change their password.

### 3. `/api/reset-password`
- API endpoint handling password reset logic.

### 4. `/validate-token`
- Validates the password reset token or OTP.

### 5. `/update-password`
- Updates the password after successful token validation.

### 6. `/verify-email`
- Verifies the user's email address before sending the reset link.

---

## Security Best Practices

Password reset mechanisms should enforce:

- Strong, cryptographically secure, single-use tokens
- Token expiration and invalidation after use
- Uniform responses to prevent user enumeration
- Strict rate limiting and CAPTCHA protection
- MFA during sensitive recovery actions
- Comprehensive logging and monitoring

---

# Brute-Force Protection / Rate Limiting

## Brute-Force Protection / Rate Limiting

Brute-force protection, commonly implemented through rate limiting, is a security control designed to prevent attackers from repeatedly guessing user credentials by submitting a high volume of authentication attempts. This is typically enforced by restricting the number of requests allowed within a defined time window, thereby reducing the risk of unauthorized access through credential guessing or credential stuffing attacks.

Rate limiting can be applied across multiple dimensions such as IP address, username, email address, device fingerprint, or session identifier.

## Common Rate Limiting Techniques

The following mechanisms are commonly used to implement brute-force protection:

### 1. IP-Based Blocking
- Blocking or throttling requests from a specific IP address after a defined number of failed attempts.

### 2. Username / Account-Based Throttling
- Limiting authentication attempts per username or account, regardless of source IP.

### 3. User-Agent-Based Blocking
- Restricting requests based on repeated failures from the same User-Agent string.

### 4. Time-Based Throttling
- Temporarily blocking authentication attempts after multiple failures within a short time window.

### 5. Account Lockout
- Locking a user account after a configurable number of failed login attempts.

### 6. CAPTCHA Enforcement
- Requiring CAPTCHA verification after suspicious or repeated authentication attempts.

### 7. Honeypots
- Deploying decoy fields or endpoints to detect and block automated brute-force tools.

### 8. Logging
- Logging all authentication attempts (successful and failed) for forensic analysis and anomaly detection.

### 9. Alerting
- Configuring alerts for unusual spikes in failed login attempts.

- I've already converted the extracted text into markdown format for you. Here's the complete markdown output:
​


## Common Rate Limiting Bypass Techniques

During security testing, the following techniques are commonly used to bypass weak rate limiting implementations:

### 1. Header-Based IP Spoofing
Some applications rely on client-controlled headers to determine the source IP address. Manipulating these headers may allow attackers to bypass IP-based rate limiting:

    X-Originating-IP: 127.0.0.1
    X-Forwarded-For: 127.0.0.1
    X-Remote-IP: 127.0.0.1
    X-Remote-Addr: 127.0.0.1
    X-Client-IP: 127.0.0.1
    X-Host: 127.0.0.1
    X-Forwarded-Host: 127.0.0.1

- Double Header Injection Example:

    
      X-Forwarded-For:
      X-Forwarded-For: 127.0.0.1

### 2. CAPTCHA Bypass

- Reusing valid CAPTCHA tokens

- Skipping CAPTCHA validation on backend APIs

- Automating CAPTCHA challenges when not properly bound to a session

### 3. Payload Manipulation

- Injecting special characters or unexpected encodings in username/password fields

- Case manipulation (User@Email.com vs user@email.com)

- Whitespace or Unicode character injection

### Brute-Force / Rate Limiting-Sensitive Endpoints
The following endpoints should be evaluated for proper rate limiting and brute-force protection:

1. /login or /signin

- Primary authentication endpoints.

2. /forgotpassword

- Password reset request endpoints vulnerable to abuse and user enumeration.

3. /register or /signup

- Account creation endpoints susceptible to automation abuse.

4. /api/login

- API-based authentication endpoints.

5. /account

- Authenticated user account endpoints.

6. /admin

- Administrative authentication endpoints requiring stricter controls.

7. /validate/credentials

- Endpoints validating user credentials.

8. /create-user

- User creation endpoints exposed to automation.

9. /api/register

- Registration APIs.

10. /validate-username

- Username availability validation endpoints.

11. /validate-email

- Email availability validation endpoints.

12. /add-user

### Security Best Practices
To effectively prevent brute-force attacks, applications should implement:

- Multi-layered rate limiting (IP + account + device)

- Uniform error messages to prevent user enumeration

- Backend enforcement (not client-side only)

- CAPTCHA tied to session and request context

- Progressive throttling instead of hard lockouts

- Centralized logging and alerting

- Protection against header-based IP spoofing
