# Blind-XSS

## Blind XSS

Blind Cross-Site Scripting (Blind XSS) is a subtype of stored or persistent XSS where malicious input provided by an attacker is saved by a web application but executed at a later time in a different context or application that the attacker cannot directly observe. Unlike regular XSS where the attacker can immediately see the effect, Blind XSS payloads execute hidden from the attacker, often when a privileged user such as an administrator or support staff views the injected input in an internal tool or dashboard.

### Key points about Blind XSS:

- The attack payload is stored and executed later, often in a component inaccessible to the attacker (e.g., internal admin panels, log viewers, support dashboards).
- Execution of the payload may be delayed by hours, days, or weeks.
- Blind XSS is difficult to detect because the attacker cannot immediately see if the payload executed.
- Outcomes of a successful blind XSS attack include stealing administrator credentials or session tokens, redirecting privileged users to malicious sites, or installing malware.
- Common targets include feedback forms, analytics parameters (UTM, referrer), logs, exception handlers, chat applications, customer ticket systems, and any internal user moderation tools.
- Detection requires tools or setups that can monitor out-of-band interactions generated when the payload executes, such as using a specially crafted payload that triggers communication with a server the attacker controls.
- Testing tools like Burp Suite with Collaborator or dedicated Blind XSS monitoring services detect when a payload is triggered indirectly.

In practice, Blind XSS payloads often use callbacks to an attacker-controlled server to notify the attacker when execution occurs, as simple alert calls are ineffective since there's no immediate client-side feedback.

Blind XSS is considered highly impactful despite detection difficulties because it affects internal systems and privileged users, potentially allowing attackers to escalate privileges or move laterally within a network.

Examples of payloads include injecting external scripts or images that call back to an attacker's server when loaded.

In summary, Blind XSS is a stealthy and delayed execution form of stored cross-site scripting that targets components not directly accessible or observable by the attacker but can still be exploited for serious security breaches.

--------------------

# Content-Security-Policy-Bypass

## Content-Security-Policy bypass

Content-Security-Policy (CSP) is a security standard designed to prevent various types of attacks, including Cross-Site Scripting (XSS) and data injection attacks, by restricting the sources from which web content can be loaded.

However, attackers and security researchers have discovered various methods to bypass or circumvent CSP under certain circumstances, often by exploiting misconfigurations, overly permissive policies, or bugs in browsers.

## Common CSP Bypass Techniques

1. **Allowing Unsafe Inline Scripts or Eval:**
   - If the CSP uses 'unsafe-inline' or 'unsafe-eval' in script-src, attackers can inject scripts via inline code or JavaScript eval-like functions.
   - Your example CSP allows 'unsafe-eval', which can be risky.

2. **Trusted Domains Hosting Malicious Scripts:**
   - If CSP permits scripts from certain external domains that are compromised or malicious, attackers can embed scripts from those domains.

3. **Whitelisting Wildcards or Insecure Sources:**
   - Allowing 'data:', 'blob:', or wildcards (*) in source directives can allow attackers to inject scripts or images from uncontrolled sources.

4. **DOM-Based CSP Bypass:**
   - Attacker exploits client-side JavaScript flaws or DOM manipulations that cause CSP to be ineffective.

5. **Exploiting Browser Bugs:**
   - Occasionally, browser vulnerabilities can be used to bypass CSP enforcement.

6. **Using JSONP or Script Gadgets:**
   - Loading scripts that execute attacker-controlled data in a trusted context to bypass restrictions.

## How to Protect Against CSP Bypass

- Avoid using 'unsafe-inline' and 'unsafe-eval' in CSP policies.
- Limit trusted script/image sources strictly to needed domains.
- Avoid wildcards in CSP directives.
- Use nonce or hash-based CSP to allow only specific inline scripts.

## Important Note
No security measure is fully foolproof. CSP is one layer of defense that complements other security measures like input validation, escaping user input, and secure coding practices.

If you are asking how attackers bypass CSP in practice, it usually involves leveraging one or more of these weaknesses or bugs in CSP implementation or policy configuration.

If you want details on a specific bypass technique or improvement suggestions for your CSP, please specify.

## The Content-Security-Policy (CSP) you provided is:

    Content-Security-Policy: img-src 'self' /assets/public/images/uploads/default.svg; script-src 'self' 'unsafe-eval' https://code.getmdl.io http://ajax.googleapis.com

## img-src 'self' /assets/public/images/uploads/default.svg

- This directive controls the sources from which images can be loaded.

- 'self' means images can be loaded only from the same origin as the webpage (same domain).

- /assets/public/images/uploads/default.svg allows images specifically from this exact relative path on the same server.

- So, images can come from your own domain and the specific image path '/assets/public/images/uploads/default.svg'.

## script-src 'self' 'unsafe-eval' https://code.getmdl.io http://ajax.googleapis.com

- This directive controls the sources from which JavaScript can be loaded and executed.

- 'self' allows scripts to be loaded from the same domain.

- 'unsafe-eval' allows the use of JavaScript constructs such as eval() or new Function(), which are generally risky as they can execute arbitrary code.

- https://code.getmdl.io and http://ajax.googleapis.com allow scripts to be loaded from these two external URLs.

------

# Html-Injection-Payload

## html injection payload to change background color for body

To change the background color of the <body> element using an HTML injection payload, you can inject an inline <style> tag or use an inline <script> tag if execution of JavaScript is permitted. Here are a few common payloads depending on the allowed context:

### 1. Inline <style> Injection (if HTML/CSS allowed)

    <style>body { background: red !important; }</style>


This payload injects a style that sets the body background to red.

### 2. Inline JavaScript Payload (if JavaScript allowed)

    <script>document.body.style.background="red";</script>


This script will immediately set the background color to red when executed.

### 3. Event Attribute Injection (if attributes are possible)

For attributes like onload in the <body> tag (less commonly allowed, but possible in some scenarios):

    <body onload="document.body.style.background='red'"> 

Or as an injected attribute in any injectable tag:

    <img src=x onerror="document.body.style.background='red'">

## Usage Note

- The effectiveness depends on where the payload is injected and what input is filtered or sanitized by the application.

- Replace 'red' with any color value you need (e.g., #0000ff for green, blue, etc.).
