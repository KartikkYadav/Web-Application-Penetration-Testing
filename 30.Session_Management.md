# Session Management

## What is Session Management?

Session Management is the process used by web applications to maintain a user's authenticated state across multiple HTTP requests. Since HTTP is a stateless protocol, session management allows the server to recognize and track a user after login.

---

## Why Session Management Is Important

- Maintains user authentication after login
- Tracks user activity across multiple requests
- Protects sensitive user data
- Prevents unauthorized access and impersonation

---

## What is a Cookie?

- A cookie is a small piece of data sent by a website and stored in a user's web browser while the user is browsing the website.
- Each time the user accesses the website, the browser sends the cookie back to the server to inform the website about the user's previous activity.

**Cookies are also known as:**
- HTTP cookies
- Web cookies
- Browser cookies

---

## 1. Session ID / Session Tokens

A secure session identifier should follow these security best practices:

- Must be random and unpredictable (**high entropy**)
- Minimum length of **128 bits**
- Should be meaningless and not contain encoded user data
- The name should not reveal its purpose (avoid names like `user`, `auth`, `sessionid`)
- Should have a defined timeout and must not be reused
- Must be invalidated immediately on logout
- Must not be derived from shared secrets such as:
  - Username
  - Password
- Must be transmitted only over secure channels (**HTTPS**)
- Session timeout duration should be appropriate based on risk and usage

---

## Where Can Session Identifiers Be Stored?

- URL parameters
- Hidden form fields
- Cookies

---

## 2. Session Persistence in URL Parameters

### Advantages

- Supports multiple simultaneous sessions in the same browser
- Works even if the client does not accept cookies

### Disadvantages

- Session ID is lost once the user leaves the website
- Session ID can leak through the **Referer** header when accessing external resources
- Session ID may be exposed via:
  - Browser history
  - Application logs
  - Proxy and server logs

---

## Session Persistence in Hidden Form Fields

### Advantages

- Supports multiple simultaneous sessions in the same browser
- Works even if the client does not accept cookies

### Disadvantages

- Session ID is lost once the user navigates away from the website
- All requests must be POST-based (session ID is not preserved in GET requests)
- Embedded resources such as images, JavaScript, and CSS cannot be securely handled

---

## Recommended Best Practice

- Use **secure, HTTP-only cookies** for session management
## Session Persistence in Hidden Form Fields

### Advantages
- Supports multiple simultaneous sessions in the same browser  
- Works even if the client does not accept cookies  

### Disadvantages
- Session ID is lost once the user navigates away from the website  
- All requests must be POST-based (session ID is not preserved in GET requests)  
- Embedded resources such as images, JavaScript, and CSS cannot be securely handled  

---

## Recommended Best Practice

- Use **secure, HTTP-only cookies** for session management  
- Enable the following cookie attributes:
  - `Secure`
  - `HttpOnly`
  - `SameSite`
- Regenerate session IDs after authentication and privilege changes  
- Implement proper session expiration and inactivity timeouts  

---

# Cookie Attributes

Cookie attributes provide additional security controls and define how, when, and where cookies are sent by the browser.

---

## Secure

- Ensures the cookie is sent only over encrypted **HTTPS (SSL/TLS)** connections  
- Prevents cookies from being transmitted over unencrypted HTTP  
- Cookies marked as `Secure` are included only in HTTPS requests  

**Example**

    Set-Cookie: session=abc123; Secure

### Domain

- Specifies the domain for which the cookie is valid
- Allows sharing cookies across subdomains when explicitly defined

### Example

    Domain=.armourinfosec.com

### The cookie will be sent to:

- armourinfosec.com

- www.armourinfosec.com

- api.armourinfosec.com

### Path

- Defines the URL path for which the cookie is valid

- The browser sends the cookie only when the request path matches the defined path

### Example

    Path=/

### Cookie is valid for:

- https://www.armourinfosec.com/

- https://www.armourinfosec.com/victim

If the path were:

    Path=/victim

### Cookie would only be sent to:

- https://www.armourinfosec.com/victim

### HttpOnly

- Prevents client-side scripts (JavaScript) from accessing the cookie

- Helps mitigate attacks such as Cross-Site Scripting (XSS)

- Cookies with HttpOnly cannot be read using document.cookie

### Example

    Set-Cookie: session=abc123; HttpOnly

### JavaScript Test (Browser Console)

    document.cookie
    alert(document.cookie)

- HttpOnly cookies will not appear in the output

### Expires

- Used to create persistent cookies

- Defines the date and time when the cookie should expire

- The browser deletes the cookie once the expiration date is reached

### Example

    Expires=Wed, 21 Oct 2026 07:28:00 GMT

If Expires is not set:

- The cookie is treated as a session cookie

- It is deleted when the browser is closed

### Security Best Practice
Always use cookies with:

- Secure

- HttpOnly

- SameSite

## Security Best Practice

- Always use cookies with:
  - `Secure`
  - `HttpOnly`
  - `SameSite`
- Avoid overly broad **Domain** and **Path** values  
- Prefer short expiration times for session cookies  
- Regenerate session cookies after authentication  

---

## References

- OWASP Session Management Cheat Sheet  
- OWASP ASVS  
- OWASP Top 10  

---

# Session Management Security Issues

---

## 3. Session Identifier Unchanged After Login

### Description
The session identifier remains the same before and after successful authentication.

### Impact
This allows **session fixation attacks**, where an attacker forces a known session ID and hijacks it after login.

### Testing Steps
1. Access the application without authenticating.
2. Capture the pre-authentication session cookie.
3. Log in and capture the post-authentication session cookie.
4. Compare both session identifiers.
5. Manually inject a known session ID before login and observe whether it persists after authentication.

### Expected Secure Behavior
- A new session ID must be generated immediately after successful authentication.

---

## 4. Failure to Invalidate Sessions on Logout

### Description
Sessions are not properly invalidated when a user logs out or when a session expires.

### Impact
An attacker with access to a valid session token can continue accessing the application even after logout.

### Testing Steps
1. Log in and capture an authenticated request.
2. Log out from the application.
3. Replay the captured request using **Burp Repeater**.
4. Observe whether the request is still accepted.

### Expected Secure Behavior
- Logged-out or expired sessions must be invalidated server-side and rejected upon reuse.

---

## 5. Authentication Request Remains Cached After Logout

### Description
Authentication responses are cached by the browser or intermediary caching mechanisms.

### Impact
Cached authentication data may be reused for replay attacks or unauthorized access.

### Testing Steps
1. Authenticate and capture the login response.
2. Log out of the application.
3. Use the browser back button to access cached pages.
4. Replay cached authentication responses using **Repeater**.

### Expected Secure Behavior
- Authentication responses must not be cached and should include appropriate cache-control headers.

---

## 6. Insufficient Session Timeout

### Description
Sessions remain active for excessively long periods without user interaction.

### Impact
Increases the likelihood of session hijacking if a session token is compromised.

### Testing Steps
1. Log in and remain idle for an extended period.
2. Periodically replay authenticated requests using **Repeater**.
3. Measure how long the session remains valid.
4. Identify differences between inactivity timeout and absolute timeout.

### Expected Secure Behavior
- Sessions should expire after a reasonable period of inactivity and enforce an absolute timeout.

---

## 7. Insufficient Session Identifier Length

### Description
Session identifiers are too short or generated using weak randomness.

### Impact
Attackers may brute-force valid session identifiers.

### Testing Steps
1. Capture session cookies.
2. Analyze:
   - Length of the session ID
   - Character set and complexity
3. Send session tokens to **Sequencer** for entropy analysis.
4. Attempt brute-force testing using **Intruder** (where permitted).

### Expected Secure Behavior
- Session identifiers must be sufficiently long and generated using a secure random source.

---

## 8. Missing Account Logout Feature

### Description
The application does not provide a logout mechanism.

### Impact
Users cannot terminate active sessions, increasing exposure on shared or public devices.

### Testing Steps
1. Review the application UI for logout functionality.
2. Inspect application endpoints for logout-related URLs.
3. Attempt manual logout via common paths:
   - `/logout`
   - `/signout`
4. Close the browser and attempt to reuse the session.

### Expected Secure Behavior
- A visible logout option must be available and must invalidate the session server-side.

---

## 9. User Credentials Stored Insecurely

### Description
User credentials are stored in plaintext or protected using weak hashing or encryption.

### Impact
Compromise of storage systems can lead to full credential disclosure.

### Testing Steps
1. Intercept authentication requests using **Proxy**.
2. Verify whether credentials are:
   - Transmitted in plaintext
   - Reused across multiple requests
3. Review responses for credential leakage.
4. Analyze password reset and profile update functionality.

### Expected Secure Behavior
- Credentials must be securely hashed and never exposed in requests or responses.

---

## 10. Concurrent User Sessions

### Description
Multiple simultaneous sessions are allowed for the same user account.

### Impact
Compromised sessions may remain active without detection.

### Testing Steps
1. Log in from Browser A and capture the session cookie.
2. Log in from Browser B or another device.
3. Use both sessions concurrently.
4. Observe whether earlier sessions are invalidated or monitored.

### Expected Secure Behavior
- Applications should restrict, monitor, or allow users to manage concurrent sessions.

---

## 11. Sensitive Cookie Set as Persistent

### Description
Sensitive session cookies are configured with persistence attributes.

### Impact
Persistent cookies are more vulnerable to theft and misuse.

### Testing Steps
1. Inspect cookies in **Proxy → HTTP history**.
2. Check for `Expires` or `Max-Age` attributes.
3. Close and reopen the browser.

### Expected Secure Behavior
- Session cookies should expire when the browser session ends.

---

## 12. Secure Flag Not Set on Sensitive Cookie

### Description
Cookies are missing the `Secure` attribute.

### Impact
Cookies may be transmitted over unencrypted HTTP connections.

### Testing Steps
1. Capture responses that set cookies.
2. Verify the presence of the `Secure` flag.
3. Attempt access over HTTP instead of HTTPS.

### Expected Secure Behavior
- Sensitive cookies must always include the `Secure` attribute.



# Types of Session Hijacking

Session hijacking is an attack where an attacker takes control of a valid user session by stealing or predicting the session identifier.

---

## 1. Network-Based Session Hijacking

### Packet Sniffing
- Attacker captures network traffic to steal session IDs  
- Common on unsecured or public Wi-Fi networks  
- Occurs when applications do not enforce HTTPS  

**Example**
- Capturing cookies over HTTP using packet sniffing tools  

---

## 2. Client-Side Session Hijacking

### Cross-Site Scripting (XSS)
- Attacker injects malicious JavaScript into a vulnerable page  
- Script steals session cookies using `document.cookie`  
- Effective when cookies are not marked as `HttpOnly`  

### Malicious Browser Extensions
- Rogue or compromised extensions can read cookies and session storage  
- Can exfiltrate session identifiers to attacker-controlled servers  

---

## 3. Session Fixation

- Attacker sets or predicts a valid session ID before user login  
- Victim logs in using the attacker-controlled session ID  
- Attacker reuses the same session ID to access the account  

---

## 4. Man-in-the-Middle (MITM) Attacks

- Attacker intercepts traffic between client and server  
- Can modify or steal session tokens in transit  
- Occurs when HTTPS is not properly enforced or validated  

---

## 5. Cross-Site Request Forgery (CSRF) with Session Abuse

- Attacker performs unauthorized actions using a victim’s active session  
- Exploits automatic cookie transmission by the browser  
- Does not steal the session ID but abuses it  

---

## 6. Session ID Prediction / Brute Force

- Attacker guesses or brute-forces session IDs  
- Happens when session IDs lack sufficient randomness or entropy  

---

## 7. Session Sidejacking

- Attacker captures session cookies from unencrypted requests  
- Especially common when only login is protected by HTTPS  
- Remaining pages use HTTP  

---

## 8. Browser History, Logs, and Referer Leakage

- Session IDs stored in URLs leak via:
  - Browser history  
  - Server or proxy logs  
  - Referer headers when visiting external sites  

---

## 9. Physical Access Hijacking

- Attacker gains access to an unlocked or shared device  
- Uses existing active session without authentication  

---

## Prevention Techniques

- Enforce HTTPS across the entire application  
- Use `Secure`, `HttpOnly`, and `SameSite` cookie attributes  
- Regenerate session IDs after login and privilege changes  
- Implement session expiration and inactivity timeouts  
- Protect against XSS and CSRF  
- Avoid session IDs in URLs  

# Cookies vs Sessions

## 1. Definition

### Cookies
- Small pieces of data stored on the **client (browser)**.
- Automatically sent with every HTTP request to the same domain/path.

### Sessions
- Data stored on the **server**.
- The client only stores a **session identifier (Session ID)**, usually in a cookie.

---

## 2. Storage Location

| Aspect | Cookies | Sessions |
|------|--------|---------|
| Stored on | Client (browser) | Server |
| Data visibility | User can view/modify | Hidden from user |
| Size limit | ~4 KB per cookie | Server-dependent |

---

## 3. Security

### Cookies

**Vulnerable if:**
- ❌ No `Secure` flag → sent over HTTP  
- ❌ No `HttpOnly` → accessible via JavaScript (**XSS risk**)  
- ❌ No `SameSite` → **CSRF risk**

- Can be **modified by the user**.

---

### Sessions

**More secure because:**
- Sensitive data stays **server-side**
- Only a **random session ID** is exposed

**Still vulnerable to:**
- Session fixation
- Session hijacking
- Improper logout / no invalidation

---

## 4. Authentication Usage

### Cookies
Often store:
- Session IDs
- JWTs
- User preferences

❌ **Should never store sensitive data**  
(passwords, tokens in plaintext)

---

### Sessions
Commonly used for:
- User authentication
- Authorization state
- Temporary user data

---

## 5. Lifetime Management

| Feature | Cookies | Sessions |
|------|--------|---------|
| Expiration | Client-controlled | Server-controlled |
| Persistence | Can persist after browser close | Usually ends on logout/timeout |
| Logout handling | Must delete cookie | Must invalidate session |

---

## 6. Performance & Scalability

### Cookies
- Sent with **every request** → increases request size
- No server storage required

### Sessions
- Require server memory or storage
- Can be scaled using:
  - Redis
  - Database-backed sessions
  - Sticky sessions

---

## 7. Typical Attacks

| Attack | Cookies | Sessions |
|------|--------|---------|
| XSS | High risk without `HttpOnly` | Session ID theft |
| CSRF | High without `SameSite` | Depends on implementation |
| Session Fixation | Possible | Common if misconfigured |
| Hijacking | Yes | Yes |

---

## 8. Best Practice (Recommended)

- Use **sessions** for authentication
- Store only a **random, high-entropy session ID** in a cookie
- Apply cookie flags:
  - `Secure`
  - `HttpOnly`
  - `SameSite`
- Invalidate sessions on:
  - Logout
  - Password change
  - Timeout

---

## Quick Summary

| Feature | Cookies | Sessions |
|-------|---------|----------|
| Client storage | Yes | No |
| Server storage | No | Yes |
| Secure by default | No | More secure |
| Recommended for auth | ❌ | ✅ |

---

### Notes
- Cookies are **client-controlled** and can be viewed or modified by users.
- Sessions keep **sensitive data server-side**, exposing only a session ID.
- Proper session invalidation is critical to prevent hijacking and fixation.

---

