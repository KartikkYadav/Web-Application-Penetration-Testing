# JSON Web Tokens (JWT)

**JWT (JSON Web Token)** is a compact, URL-safe token format used to securely transmit claims between two parties. JWTs are commonly used for **authentication and authorization** in modern web applications, APIs, and microservices.

---

## What is a JWT?

JWTs are:

- Stateless  
- Compact  
- Digitally signed (and optionally encrypted)  
- Easy to verify without server-side session storage  

JWTs use:

- **JWS (JSON Web Signature)** for signing  
- **JWE (JSON Web Encryption)** for encryption (less common)

---

## JWT Structure

A JWT consists of **three Base64URL-encoded parts**, separated by dots (`.`):

    Header.Payload.Signature


## Example JWT

    eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
    eyJpc3MiOiJleGFtcGxlLm9yZyIsImF1ZCI6ImV4YW1wbGUuY29tIiwiaWF0IjoxNzI1OTYyNjY4LCJleHAiOjE3MjU5NjYyNjgsInVzZXJuYW1lIjoiYWRtaW4ifQ
    VihfFUGAtVYKVvOAVPCJiZa231PNOROdOCZodxxZVicdM


## 1. Header

The header contains metadata about the token:

- Token type (`JWT`)
- Signing algorithm (`alg`)

### Decode Header

    echo -n "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9" | base64 --decode

### Decoded Header

    {
      "typ": "JWT",
      "alg": "HS256"
    }

## 2. Payload (Claims)

The payload contains claims about the user and token metadata.

### Claim Types

Registered claims (standard fields)

- iss ‚Äì issuer
- sub ‚Äì subject
- aud ‚Äì audience
- exp ‚Äì expiration
- iat ‚Äì issued at

### Public claims
- Publicly defined, collision-resistant claims

### Private claims
- Custom application-specific claims

### Decode Payload

    echo -n "eyJpc3MiOiJleGFtcGxlLm9yZyIsImF1ZCI6ImV4YW1wbGUuY29tIiwiaWF0IjoxNzI1OTYyNjY4LCJleHAiOjE3MjU5NjYyNjgsInVzZXJuYW1lIjoiYWRtaW4ifQ" | base64 --decode

### Decoded Payload

    {
      "iss": "example.org",
      "aud": "example.com",
      "iat": 1725962668,
      "exp": 1725966268,
      "username": "admin"
    }

‚ö†Ô∏è Important: JWT payloads are encoded, not encrypted. Anyone with the token can read the payload.

## 3. Signature
The signature ensures:

- Token integrity
- Token authenticity

### Signature Creation

    HMACSHA256(
      base64UrlEncode(header) + "." + base64UrlEncode(payload),
      secret
### Why the signature matters

- Prevents tampering
- Proves the token was issued by a trusted party

‚ö†Ô∏è The signature is cryptographic data and cannot be meaningfully decoded like the header or payload.

### JWT Signature Verification
When a server receives a JWT:

1. Extracts the header and payload
2. Recomputes the signature using the expected key
3. Compares it with the received signature
4. If they match ‚Üí token is valid

If verification fails ‚Üí token is rejected

### JWT Signing Algorithms
#### HMAC (HS*)

- Symmetric key
- Same secret used to sign and verify
- Common algorithm: HS256
- Risk: Secret disclosure allows full token forgery

#### RSA (RS*)

- Asymmetric cryptography
- Private key ‚Üí signing
- Public key ‚Üí verification
- Common algorithm: RS256
- Preferred for distributed systems

#### ECDSA (ES*)

- Elliptic Curve Cryptography
- Smaller keys, strong security
- Common algorithm: ES256

#### RSASSA-PSS (PS*)

- RSA variant with probabilistic padding
- More resistant to cryptographic attacks
- Example: PS256

#### none Algorithm

- No signature verification
- Extremely insecure
- Must never be enabled

### Choosing the Right Algorithm

- Use HS256 only when secrets are securely managed
- Prefer RS256 or ES256 for production systems
- Never accept alg: none
- Enforce strict algorithm whitelisting

### JWT Security Considerations

- JWT ‚â† encrypted token
- Do not store sensitive data in payload
- Always validate:
      - Signature
      - Expiration (exp)
      - Issuer (iss)
      - Audience (aud)
- Rotate signing keys regularly
- Use short expiration times

### JWT Editor (Burp Suite)
JWT Editor is a Burp Suite extension used for JWT testing:

- Decode / modify JWTs
- Sign and re-sign tokens
- Encrypt / decrypt JWTs
- Test JWT-based authentication flaws

### Extension:
https://portswigger.net/bappstore/26aaa5ded2f4beea19e2ed8345a93dd

## Attacking JWT ‚Äì Weak Secret (HS256)
If a weak secret is used, attackers can brute-force it.

## Brute-force JWT Secret

    hashcat -m 16500 -a 0 jwt.txt /opt/jwt.secrets.list

### Impact
- Modify claims (e.g. role=admin)
- Re-sign valid tokens
- Authentication bypass

### Key Takeaways
- JWTs are signed, not encrypted by default
- Weak secrets break JWT security
- Algorithm confusion is dangerous


# Lab-2 JWT Authentication Bypass via Weak Signing Key

**Web Application Penetration Test / JSON Web Tokens (JWT)**

**Reference:**  
https://github.com/wallarm/jwt-secrets/blob/master/jwt.secrets.list

---

## Vulnerability Type

**Weak / Guessable HMAC Secret (HS256)**

### Impact
- Token forgery  
- Privilege escalation  
- Administrator account takeover  

---

## High-Level Attack Flow

**JWT signed with HS256**

- Weak shared secret
- Secret brute-forced offline
- Attacker can re-sign tokens
- Full control over JWT claims
- Admin access achieved

---

### What we did=
- first of all this is using HS256 Algorithem to sign the token the HS256 uses same key for authenticating and verifying
- This method make it vulnerable we have decoded the token using hashcat
- Than we generate the token with a same secrete key embede in it .
- Use it to login the  admin panel
## Step-by-Step Breakdown

### 1. Identify JWT-Based Authentication

After login, intercept the request:        

    GET /my-account

You observe:

    Cookie: session=<JWT>

This confirms:

- JWT is used as the session token
- Algorithm is HS256 (symmetric)

### 2. Confirm Access Control
Change the request path in Repeater:

    /my-account ‚Üí /admin

Response:

Access denied

This confirms /admin requires administrator privileges.

### 3. Brute-Force the Signing Key (Offline)

Why This Is Possible
- HS256 uses one shared secret
- Weak secrets are brute-forceable
- JWT verification happens offline
- No rate limiting applies

### Using Hashcat
#### Command:

    hashcat -a 0 -m 16500 <JWT> jwt.secrets.list

#### Result:

    <JWT>:secret1

#### Secret key found: secret1

### Using John (Alternative)

    john jwt.txt

#### Output:

secret1

This confirms the signing key is trivial.

### 4. Generate a Forged Signing Key (Burp)
Why This Step Matters
Burp‚Äôs JWT Editor expects a JWK, not raw text.

#### Steps

1. Base64-encode the secret

        secret1 ‚Üí c2VjcmV0MQ==

2. Navigate to:

        Burp ‚Üí JWT Editor Keys ‚Üí New Symmetric Key

3. Click Generate

4. Replace:

        "k": "GENERATED_VALUE"

with:

    "k": "c2VjcmV0MQ=="

Save the key

You now possess the real signing key trusted by the server.

### 5. Modify and Re-Sign the JWT
Payload Tampering
In Repeater ‚Üí JSON Web Token tab:

    "sub": "administrator"

#### Sign the Token

- Click Sign
- Select the forged key
- Enable Don‚Äôt modify header
- Confirm

#### The token is now:

- Cryptographically valid
- Signed with the correct secret
- Claiming administrator privileges

### 6. Access Admin Panel
Send the request:

    GET /admin

### Result:
‚úÖ Admin panel loads successfully

#### Complete the Lab
Target endpoint:

    /admin/delete?username=carlos

Send the request ‚Üí Lab solved

### Why This Works (Very Important)
The application:

- Uses HS256 (shared secret)
- Uses a weak signing key
- Trusts JWT claims after verification
- Allows offline brute-forcing

Once the secret is known:

# 3.  JWT Authentication Bypass via JWK Header Injection

> **Category:** Web Application Penetration Testing  
> **Topic:** JSON Web Tokens (JWT)  
> **Lab:** PortSwigger Web Security Academy

üîó **Lab Link:**  
https://portswigger.net/web-security/jwt/lab-jwt-authentication-bypass-via-jwk-header-injection

---

## üìå Vulnerability Overview

- **Vulnerability Type:** Trusting attacker-supplied JWKs in the JWT header
- **Impact:**  
  An attacker can sign their own JWTs and gain **administrator access**

---

## üß† Core Idea

JWT supports a `jwk` (JSON Web Key) field inside the JWT header, which can embed a public key.

If a server **trusts the JWK provided by the client**, instead of using a trusted key store, the entire authentication mechanism is compromised.

### Example JWT Header


    {
      "kid": "b2fabedf-f22a-4a2d-9610-e7f7b053cb76",
      "typ": "JWT",
      "alg": "RS256",
      "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "kid": "b2fabedf-f22a-4a2d-9610-e7f7b053cb76",
        "n": "yoYEnHxMfAAMLOVTECGprYbCAbPDpazwI4qFMDjdh_yNR_9HLxpAhSNKXHhrGiMUCSx2c3VGGgm4H9SL7TSSCBScS1ALu9Pyas2n7ZB2Xe2dXJ7Uu7vc_homOdCialvxxd2XRPbHd_XpNIIFpjOrkDmmCUsTUm30a7XcnabwbZ6YSkEXmxfZIKmOLatDhxzB18GJ2EnfnfcLvMYTLaumLcOsOpZajGuxqijuPGX3cvozyacLKP6hpH9EYsjGm3M_q3yEILUCQwhuf4xJUM2pOFZFSQVZBmOdRuv4Xio2bgHhMarpC3p7AS3YMXpo7NwNzFprYx4aAIMJzogdei_w"
      }
    }

## üêû The Bug
The server blindly trusts the JWK inside the JWT, instead of verifying the token using a pre-configured trusted key.

## üß® Attacker Logic

1. Generate an attacker-controlled RSA key pair
2. Sign a JWT using the private key
3. Embed the public key in the JWT header using jwk
4. Server verifies the signature using the attacker-supplied key
5. Token is accepted ‚Üí Authentication bypass

## üöÄ Step-by-Step Exploitation
### 1Ô∏è‚É£ Generate an Attacker-Controlled RSA Key
In Burp Suite:

- Go to JWT Editor ‚Üí Keys
- Click New RSA Key
- Click Generate
- Save the key

You now control:

- Private key ‚Üí Used to sign the JWT
- Public key ‚Üí Injected via jwk

### 2Ô∏è‚É£ Intercept the Admin Request
In Repeater:

    GET /admin

- Access denied (expected)
- Switch to the JSON Web Token tab

### 3Ô∏è‚É£ Modify the JWT Payload
Change:

    "sub": "wiener"

To:

    "sub": "administrator"

‚ö†Ô∏è This alone will not work ‚Äî the token must be re-signed.

### 4Ô∏è‚É£ Inject the JWK into the JWT Header
In the JWT Editor tab:
1. Click Sign
2. Select your RSA key
3. Uncheck ‚ÄúDon‚Äôt modify header‚Äù
4. Ensure JWK is included (Burp does this automatically)

Updated JWT header:

    {
      "alg": "RS256",
      "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "n": "..."
      }
    }

‚úî The public key inside jwk matches the private key used to sign the token.

### 5Ô∏è‚É£ Send the Forged Request

    GET /admin

### ‚úÖ Result:
Admin panel loads successfully

### üß© Finish the Lab
Send the following request:

    /admin/delete?username=carlos

‚úÖ Lab Solved

### üîç Why This Works (Very Important)
The application:

- Accepts jwk from the JWT header
- Uses it directly for signature verification
- Does not restrict trusted signing keys

### ‚ùå Broken Trust Model

1. Attacker provides key
2. Server trusts key
3. Signature validates
4. Claims are trusted

### ‚û°Ô∏è JWT security is completely defeated

### üõ°Ô∏è Prevention Tips

- Never trust jwk supplied by the client
- Maintain a server-side trusted key store
- Enforce strict kid validation
- Disable dynamic key loading unless absolutely required


