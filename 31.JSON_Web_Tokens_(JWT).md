# JSON Web Tokens (JWT)

**JWT (JSON Web Token)** is a compact, URL-safe token format used to securely transmit claims between two parties. JWTs are commonly used for **authentication and authorization** in modern web applications, APIs, and microservices.

---

## What is a JWT?

JWTs are:

- Stateless  
- Compact  
- Digitally signed (and optionally encrypted)  
- Easy to verify without server-side session storage  

JWTs use:

- **JWS (JSON Web Signature)** for signing  
- **JWE (JSON Web Encryption)** for encryption (less common)

---

## JWT Structure

A JWT consists of **three Base64URL-encoded parts**, separated by dots (`.`):

    Header.Payload.Signature


## Example JWT

    eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
    eyJpc3MiOiJleGFtcGxlLm9yZyIsImF1ZCI6ImV4YW1wbGUuY29tIiwiaWF0IjoxNzI1OTYyNjY4LCJleHAiOjE3MjU5NjYyNjgsInVzZXJuYW1lIjoiYWRtaW4ifQ
    VihfFUGAtVYKVvOAVPCJiZa231PNOROdOCZodxxZVicdM


## 1. Header

The header contains metadata about the token:

- Token type (`JWT`)
- Signing algorithm (`alg`)

### Decode Header

    echo -n "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9" | base64 --decode

### Decoded Header

    {
      "typ": "JWT",
      "alg": "HS256"
    }

## 2. Payload (Claims)

The payload contains claims about the user and token metadata.

### Claim Types

Registered claims (standard fields)

- iss – issuer
- sub – subject
- aud – audience
- exp – expiration
- iat – issued at

### Public claims
- Publicly defined, collision-resistant claims

### Private claims
- Custom application-specific claims

### Decode Payload

    echo -n "eyJpc3MiOiJleGFtcGxlLm9yZyIsImF1ZCI6ImV4YW1wbGUuY29tIiwiaWF0IjoxNzI1OTYyNjY4LCJleHAiOjE3MjU5NjYyNjgsInVzZXJuYW1lIjoiYWRtaW4ifQ" | base64 --decode

### Decoded Payload

    {
      "iss": "example.org",
      "aud": "example.com",
      "iat": 1725962668,
      "exp": 1725966268,
      "username": "admin"
    }

⚠️ Important: JWT payloads are encoded, not encrypted. Anyone with the token can read the payload.

## 3. Signature
The signature ensures:

- Token integrity
- Token authenticity

### Signature Creation

    HMACSHA256(
      base64UrlEncode(header) + "." + base64UrlEncode(payload),
      secret
### Why the signature matters

- Prevents tampering
- Proves the token was issued by a trusted party

⚠️ The signature is cryptographic data and cannot be meaningfully decoded like the header or payload.

### JWT Signature Verification
When a server receives a JWT:

1. Extracts the header and payload
2. Recomputes the signature using the expected key
3. Compares it with the received signature
4. If they match → token is valid

If verification fails → token is rejected

### JWT Signing Algorithms
#### HMAC (HS*)

- Symmetric key
- Same secret used to sign and verify
- Common algorithm: HS256
- Risk: Secret disclosure allows full token forgery

#### RSA (RS*)

- Asymmetric cryptography
- Private key → signing
- Public key → verification
- Common algorithm: RS256
- Preferred for distributed systems

#### ECDSA (ES*)

- Elliptic Curve Cryptography
- Smaller keys, strong security
- Common algorithm: ES256

#### RSASSA-PSS (PS*)

- RSA variant with probabilistic padding
- More resistant to cryptographic attacks
- Example: PS256

#### none Algorithm

- No signature verification
- Extremely insecure
- Must never be enabled

### Choosing the Right Algorithm

- Use HS256 only when secrets are securely managed
- Prefer RS256 or ES256 for production systems
- Never accept alg: none
- Enforce strict algorithm whitelisting

### JWT Security Considerations

- JWT ≠ encrypted token
- Do not store sensitive data in payload
- Always validate:
      - Signature
      - Expiration (exp)
      - Issuer (iss)
      - Audience (aud)
- Rotate signing keys regularly
- Use short expiration times

### JWT Editor (Burp Suite)
JWT Editor is a Burp Suite extension used for JWT testing:

- Decode / modify JWTs
- Sign and re-sign tokens
- Encrypt / decrypt JWTs
- Test JWT-based authentication flaws

### Extension:
https://portswigger.net/bappstore/26aaa5ded2f4beea19e2ed8345a93dd

## Attacking JWT – Weak Secret (HS256)
If a weak secret is used, attackers can brute-force it.

## Brute-force JWT Secret

    hashcat -m 16500 -a 0 jwt.txt /opt/jwt.secrets.list

### Impact
- Modify claims (e.g. role=admin)
- Re-sign valid tokens
- Authentication bypass

### Key Takeaways
- JWTs are signed, not encrypted by default
- Weak secrets break JWT security
- Algorithm confusion is dangerous


# Lab-2 JWT Authentication Bypass via Weak Signing Key

**Web Application Penetration Test / JSON Web Tokens (JWT)**

**Reference:**  
https://github.com/wallarm/jwt-secrets/blob/master/jwt.secrets.list

---

## Vulnerability Type

**Weak / Guessable HMAC Secret (HS256)**

### Impact
- Token forgery  
- Privilege escalation  
- Administrator account takeover  

---

## High-Level Attack Flow

**JWT signed with HS256**

- Weak shared secret
- Secret brute-forced offline
- Attacker can re-sign tokens
- Full control over JWT claims
- Admin access achieved

---

### What we did=
- first of all this is using HS256 Algorithem to sign the token the HS256 uses same key for authenticating and verifying
- This method make it vulnerable we have decoded the token using hashcat
- Than we generate the token with a same secrete key embede in it .
- Use it to login the  admin panel
## Step-by-Step Breakdown

### 1. Identify JWT-Based Authentication

After login, intercept the request:        

    GET /my-account

You observe:

    Cookie: session=<JWT>

This confirms:

- JWT is used as the session token
- Algorithm is HS256 (symmetric)

### 2. Confirm Access Control
Change the request path in Repeater:

    /my-account → /admin

Response:

Access denied

This confirms /admin requires administrator privileges.

### 3. Brute-Force the Signing Key (Offline)

Why This Is Possible
- HS256 uses one shared secret
- Weak secrets are brute-forceable
- JWT verification happens offline
- No rate limiting applies

### Using Hashcat
#### Command:

    hashcat -a 0 -m 16500 <JWT> jwt.secrets.list

#### Result:

    <JWT>:secret1

#### Secret key found: secret1

### Using John (Alternative)

    john jwt.txt

#### Output:

secret1

This confirms the signing key is trivial.

### 4. Generate a Forged Signing Key (Burp)
Why This Step Matters
Burp’s JWT Editor expects a JWK, not raw text.

#### Steps

1. Base64-encode the secret

        secret1 → c2VjcmV0MQ==

2. Navigate to:

        Burp → JWT Editor Keys → New Symmetric Key

3. Click Generate

4. Replace:

        "k": "GENERATED_VALUE"

with:

    "k": "c2VjcmV0MQ=="

Save the key

You now possess the real signing key trusted by the server.

### 5. Modify and Re-Sign the JWT
Payload Tampering
In Repeater → JSON Web Token tab:

    "sub": "administrator"

#### Sign the Token

- Click Sign
- Select the forged key
- Enable Don’t modify header
- Confirm

#### The token is now:

- Cryptographically valid
- Signed with the correct secret
- Claiming administrator privileges

### 6. Access Admin Panel
Send the request:

    GET /admin

### Result:
✅ Admin panel loads successfully

#### Complete the Lab
Target endpoint:

    /admin/delete?username=carlos

Send the request → Lab solved

### Why This Works (Very Important)
The application:

- Uses HS256 (shared secret)
- Uses a weak signing key
- Trusts JWT claims after verification
- Allows offline brute-forcing

Once the secret is known:




